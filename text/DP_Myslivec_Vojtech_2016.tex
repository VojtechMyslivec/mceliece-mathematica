% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,czech,hidelinks]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{multirow} % multirow for tabular
\usepackage{graphicx} %graphics files inclusion
\usepackage{amsmath} %advanced maths
\usepackage{amssymb} %additional math symbols

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{dirtree} %directory tree visualisation
% \usepackage{textcomp} % \textcopyleft

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries
\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens
\newcommand{\0}{{\textcolor[gray]{0.80}{0}}}

\newenvironment{algoritmus}{
    \floatname{algorithm}{Algoritmus}
    \begin{algorithm}
}{\end{algorithm}}

\newtheorem{tvrzeni}{Tvrzení}
\newtheorem{definice}{Definice}
\newtheorem{veta}{Věta}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Hlavička
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\department{Katedra počítačových systémů}
\title{Asymetrický šifrovací algoritmus McEliece}
\authorGN{Vojtěch}
\authorFN{Myslivec}
\authorWithDegrees{Bc. Vojtěch Myslivec}
\supervisor{prof. Ing. Róbert Lórencz, CSc.}
%TODO
%\acknowledgements{Rodina, Lórencz, Kalvoda, Guth}
%TODO
\abstractCS{Tady bude nejaky kuuul abstakt } %TODO
%TODO
\abstractEN{Sem doplňte ekvivalent abstraktu Vaší práce v~angličtině.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{McEliece, asymetrická kryptografie, postkvantová kryptografie,
binární Goppa kódy, konečná tělesa, polynomy, Wolfram Mathematica}
\keywordsEN{McEliece, public-key cryptography, post-quantum cryptography, binary
Goppa codes, finite fields, polynomy, Wolfram Mathematica}




% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Dokument
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

% ====================================================================
% ====================================================================
% ====================================================================
\begin{introduction}
Tato práce se zabývá asymetrickým kryptosystémem \emph{McEliece}. Mezi největší
přednosti tohoto systému patří jeho odolnost vůči kvantovým počítačům a je tak
jedním z~vhodných kandidátů pro asymetrickou kryptografii pro postkvantovou
dobu.

%TODO
V~prvních kapitolách této práce jsou popsány nezbytné primitivy z~oblasti
matematiky a teorie kódování, které jsou potřeba pro pochopení a použití
kryptosystému McEliece. Jedná se především o~počítání s~\emph{konečnými tělesy}
a \emph{polynomy} (kapitola \ref{kap_telesa}) a binární \emph{Goppa} kódy
(kapitola \ref{kap_kody}).

Kryptosystému \emph{McEliece} se věnuje kapitola \ref{kap_mceliece}. Kromě
základního popisu generování klíčů a algoritmů pro šifrování a dešifrování je
probráno i \emph{Niederreiterovo} schéma -- \uv{úprava} kryptosystému
\emph{McEliece} pro získání \emph{digitálního podpisu}. Jsou ukázány slabiny,
nevýhody i možné útoky na kryptosystém McEliece a též zmíněna praktická varianta
systému odolná vůči těmto aspektům.

V~poslední části  práce je probrána implementace kryptosystému \emph{McEliece}
v~softwaru \emph{Wolfram Mathematica} včetně změřených časových
% TODO a prostorových
složitostí (kapitola \ref{kap_implementace}),.

\end{introduction}

%\chapter{Cíl práce}

% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Obecná algebra}\label{kap_telesa}
V~kapitole jsou probrány definice a algoritmy nutné pro práci s~\emph{konečnými
tělesy} a \emph{polynomy} nad konečným tělesem. V~práci se předpokládá
základních znalostí z~oblasti \emph{algebry}. Pro tato témata je doporučena
literatura \cite{FIT_MPI,FIT_MKY,FIT_LIN,FIT_BHW,Paar_Understanding} (kde lze též
najít většinu důkazů následujících vět).

% ====================================================================
\section{Základní termíny}
Pro ujasnění je uvedena definice tělesa:

\begin{definice}[Těleso]
    Nechť $M$ je neprázdná množina a $+$ a $\cdot$ binární operace\footnote{
        Pro zjednodušení zápisu je $\cdot$ často vynecháváno.
    }. Struktura
    $T=\big(M, +, \cdot \big)$ se nazývá těleso, pokud platí
    \begin{enumerate}
        \item $\big(M, +\big)$ je \emph{komutativní grupa} (nazývána
            \emph{aditivní})
        \item $\big(M\setminus\{\mathit{0}\}, \cdot \big)$\footnote{
                Prvek $\mathit{0}$ je \emph{nulový} (\emph{neutrální}) prvek
                \emph{aditivní grupy}.
            } je \emph{grupa} (nazývána
            \emph{multiplikativní})
        \item Platí (levý i pravý) \emph{distributivní zákon}:
            $$\forall a,b,c \in M : \big( a(b+c) = a b + a c \big) \land \big(
            (b+c)a = b a + c a \big) $$
    \end{enumerate}
\end{definice}

{\setlength{\parindent}{0cm}
\emph{Těleso}, které má konečný počet prvků, se nazývá \emph{konečné těleso}.
}

\begin{veta}
    Nechť $T$ je \emph{konečné těleso}, pak jeho počet prvků (\emph{řád}) je
    $p^n$, kde $p$ je prvočíslo a $n \in \mathbb{N} \land n \geq 1 $.
\end{veta}
%\begin{proof} TODO
%\end{proof}

Číslo $p$ se nazývá \emph{charakteristika}. Navíc platí, že \emph{všechna
konečná tělesa} se stejným počtem prvků jsou navzájem \emph{izomorfní}.
\emph{Konečné těleso} řádu $p^n$ je tedy dále označováno jako $GF(p^n)$
(z~anglického \emph{Gallois field}, dle francouzského matematika
\emph{Évariste Galois}).

% ====================================================================
\section{Reprezentace prvků}
Jak bude ukázáno dále, je vhodné prvky tělesa $GF(p^n)$ reprezentovat jako
\emph{polynomy} s~koeficienty z~množiny $\mathbb{Z}_p=\{0,1,\ldots,p-1\}$, tedy
prvek $a \in GF(p^n)$ lze zapsat:
$$ A(x) = \sum_{i=0}^{n-1} a_i x^i, a_i \in \mathbb{Z}_p $$

O~takovém polynomu říkáme, že je to \emph{polynom nad tělesem $GF(p)$ (řádu
maximálně $n-1$)}. Na prvek $a$ je též možné se dívat jako na vektor či $n$-tici
koeficientů~$a_i$:
$$ A(x) \cong a \cong (a_{n-1} a_{n-2} \ldots a_0) \cong a_{n-1} a_{n-2}
\ldots a_0 $$

V~této práci se mezi těmito reprezentacemi prvků nadále volně přechází, jak
bude v~daném kontextu potřeba\footnote{
    V~některých materiálech se používá i obráceného zápisu
    $(a_0 a_1 \ldots a_p-1)$.
}.

% ====================================================================
\section{Operace v~tělese $GF(p^n)$}
V~následujících sekcích jsou probrány operace potřebné pro počítání
s~tělesy $GF(p^n)$. Konkrétní zvolené algoritmy a jejich implementace
je detailně popsána v~kapitole \ref{kap_implementace}.

% --------------------------------------------------------------------
\subsection{Sčítání}
Sčítání v~tělese $GF(p^n)$ je definováno stejně jako sčítání polynomů, s~tím, že
sčítání jednotlivých koeficientů je prováděno \emph{modulo $p$} (v~tělese $GF(p)$:
$$ A(x) + B(x) = \sum a_i x^i + \sum b_i x^i = \sum \left|a_i + b_i\right|_p x^i $$


% --------------------------------------------------------------------
\subsection{Násobení}
Násobení v~tělese $GF(p^n)$ nelze provádět \uv{po složkách}, jako je tomu
u~sčítání. U~takto definované operace by většina prvků neměla (multiplikativní)
\emph{inverzi} a nejednalo by se tak o~\emph{těleso}.

Při násobení prvků se opět využije jejich reprezentace pomocí polynomů.
Výsledkem násobení pak je:
$$ A(x) \cdot B(x) = \sum_{i=0}^{n-1} a_i x^i \cdot \sum_{i=0}^{n-1} b_i x^i =
\sum_{i=0}^{2n-2} \left|\sum_{j+k=i} a_j \cdot b_k\right|_p x^i$$

Jak je naznačeno, násobení i sčítání koeficientů se provádí \emph{modulo} $p$
(v~tělese $GF(p)$.

Kvůli uzavřenosti násobení v~tělese je nutné zavést operaci $A(x) \mod P(x)$,
neboli zbytek po dělení polynomu $A(x)$ polynomem $P(x)$. Dále je třeba pro
určení tělesa $GF(p^n)$ určit \emph{ireducibilní} polynom, který bude použitý
při operaci násobení.

\begin{definice}
    Polynom $P(x)$ nad tělesem $GF(p)$ je \emph{ireducibilní} právě tehdy, když
    pro každé dva polynomy $A(x)$ a $B(x)$ nad $GF(p)$ platí:
    $$ A(x) \cdot B(x) = P(x) \Rightarrow \left( deg(A(x)) = 0 \right) \lor
    \left( deg(B(x)) = 0 \right)$$
\end{definice}

Neboli pro \emph{ireducibilní} polynom platí, že neexistuje rozklad na polynomy
nad $GF(p)$ stupně alespoň $1$.

\paragraph{Příklad} Polynom $x^3+x+1$ je nad tělesem $GF(2)$ \emph{ireducibilní},
protože neexistuje jeho rozklad na polynomy stupně alespoň $1$. \\
Polynom $x^2+1$ není nad tělesem $GF(2)$ \emph{ireducibilní}, protože:
$$(x+1)\cdot(x+1) = x^2 + \left|1+1\right|_2x + 1 = x^2+1 $$

Nyní je možné zavést operaci násobení dvou prvků tělesa jako násobení dvou
polynomů \emph{modulo} \emph{zadaný ireducibilní} polynom:
$$ A(x) \cdot B(x) = \sum a_i x^i \cdot \sum b_i x^i =
\sum \left|\sum_{j+k=i} a_j \cdot b_k\right|_p x^i \mod P(x) $$


\paragraph{Poznámka} Pokud by zvolený $P(x)$ nebyl \emph{ireducibilní}, jednalo
by se o~\emph{okruh}, nikoliv o~\emph{těleso}, protože by neexistovala
\emph{multiplikativní inverze} pro některé prvky a navíc by i existovaly
tzv. \emph{dělitelé nuly}.


% --------------------------------------------------------------------
\subsection{Umocňování}
Pro rozšíření operací o~opakované násobení je vhodné zavést operaci umocňování.

\begin{definice}
    Pro prvek $a$ tělesa $T$ a číslo $n\in\mathbb{N}$ je operace
    umocňování definována následovně:
    \begin{align*}
        a^0     &= 1 \\
        a^n     &= \underbrace{a \cdot a \cdot \ldots \cdot a}_{\text{$n$-krát}}\\
        a^{-n}  &= \left(a^{-1}\right)^n
    \end{align*}
\end{definice}

Pro efektivní výpočet mocniny prvku je vhodné použít algoritmus
\emph{Square-and-Multiply}, kde se dílčí operace \uv{square} a \uv{multiply}
provádí operací $\cdot$ v~daném tělese $GF(p^n)$.

% --------------------------------------------------------------------
\subsection{Inverze}
\emph{Inverzi} v~\emph{grupě} lze obecně definovat následovně:
\begin{definice}[Inverze]
    Nechť $a$ je prvkem a $\mathbb{O}$ neutrálním prvkem \emph{grupy} \\
    $G = (M,\circ)$. Prvek $\bar{a}$ je \emph{inverzí} prvku $a$, pokud
    platí následující rovnice:
    $$ a \circ \bar{a} = \mathbb{O} $$
\end{definice}

\subsubsection{Aditivní inverze}
Inverze v~\emph{aditivní grupě} je značena znaménkem minus \uv{$-$} a je
z~definice velmi triviální:
$$ \left| A(x) + (-A(x)) \right|_p = 0 \Rightarrow
-A(x) = \sum \left|-a_i\right|_p x^i $$

Neboli je to aditivní inverze jednotlivých koeficientů \emph{modulo} $p$
(v~tělese $GF(p)$).


\subsubsection{Multiplikativní inverze}
Inverze v~\emph{multiplikativní grupě} je značena záporným exponentem
\uv{$^{-1}$} či symbolem dělení.
$$ \left| A(x) \cdot A(x)^{-1} \right|_p =
\left| \frac{A(x)}{A(x)} \right|_p = 1 $$

Tuto \emph{multiplikativní inverzi} je třeba počítat \emph{rozšířeným Euklidovým
algoritmem pro polynomy} (\emph{EEA}), či případně jinými algoritmy, jako je
např. \emph{algoritmus Itoh-Teechai-Tsujii} (\emph{ITT}) \cite{FIT_BHW,ITT}.

\emph{Rozšířený Euklidův algoritmus} \emph{pro polynomy}, stejně jako
v~modulární aritmetice (neboli pro tělesa $GF(p)$), stojí na nalezení
\emph{Bézoutovy rovnosti}. Pro výpočet \emph{EEA} je třeba výpočtu dělení
polynomů se zbytkem\footnote{
    Někdy uváděno jako dlouhé dělení.
}.

%TODO příklad!

% ====================================================================
\section{Rozšířená tělesa}

% TODO
\emph{Prvotěleso}


% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Lineární kódy}\label{kap_kody}

% ====================================================================
\section{Kódování}

% ====================================================================
\section{Lineární kódy}
% --------------------------------------------------------------------
\subsection{Hammingovy kódy}

% ====================================================================
\section{Goppa kódy}
\emph{Ireducibilní binární Goppa kódy}



% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Kryptosystém McEliece}\label{kap_mceliece}
Kryptosystém \emph{McEliece} je asymetrický šifrovací algoritmus, publikovaný
poprvé v~roce \emph{1978} \emph{Robertem McEliece} \cite{McEliece}.
V~následujících kapitolám jsou probrány algoritmy navržené \emph{Robertem
McEliece}, dále \emph{Niederreiterovo schéma} -- varianta pro získání
elektronického podpisu -- a nakonec jsou zmíněny slabiny a existující útoky na
tento kryptosystém.

\paragraph{Poznámka} V~této kapitole je nadále předpokládáno počítání
s~hodnotami z~tělesa $GF(2)$, respektive s~\emph{bity}.

% ====================================================================
\section{Asymetrické šifrování McEliece}
Asymetrický kryptosystém \emph{McEliece} je založený na lineárních samoopravných
kódech. V~následujících odstavcích systém popsán tak, jak byl
definován v~\cite{McEliece}:

% --------------------------------------------------------------------
\subsection{Generování klíčů}
Generování klíčů probíhá následovně:

\begin{enumerate}
    \item Zvolí se \emph{lineární kód}\footnote{
            V~článku je kryptosystém definovaný pro libovolný \emph{lineární
            kód} opravující zvolený počet chyb a jsou zmíněny \emph{Goppa} kódy
            jako vhodný příklad k~použití. Jak bude ukázáno dále, ne všechny
            lineární kódy jsou pro \emph{McEliece} vhodné.
        } $(n,k)$, opravující $t$ chyb (a pro který je znám efektivní dekódovací
        algoritmus) s~odpovídající $k \times n$ \emph{generující maticí}~$G$.
    \item Vygeneruje se \emph{náhodná} $k \times k$ \emph{regulární} matice $S$.
    \item Vygeneruje se \emph{náhodná} $n \times n$ \emph{permutační} matice $P$.
    \item Vypočítá se $k \times n$ matice $\hat{G} = S G P$.
\end{enumerate}

Potom čísla $k$, $n$ a $t$ jsou \emph{veřejné parametry} systému, matice
$\hat{G}$ je \emph{veřejný klíč} a kód s~maticí $G$ a matice $S$ a $P$ jsou
\emph{soukromý klíč}.

% --------------------------------------------------------------------
\subsection{Algoritmy pro šifrování a dešifrování}
\subsubsection{Šifrování}
Šifrování zprávy $m$ (o~délce $k$ bitů) veřejným klíčem $\hat{G}$ probíhá
následujícím způsobem:

\begin{enumerate}
    \item Vygeneruje se náhodný vektor $z$ délky $n$ s~\emph{Hammingovou vahou}
        maximálně $t$\footnote{
            V~některých pozdějších pracích na toto téma je
            uvedeno právě $t$.
        }.
    \item Šifrovaná zpráva $c$ délky $n$ se sestrojí následujícím způsobem:
        $$ c = m \hat{G} + z$$
\end{enumerate}

\subsubsection{Dešifrování}
Obdržená zašifrovaná zpráva $c$ (délky $n$) se dešifruje následujícím způsobem:

\begin{enumerate}
    \item Vypočítá se vektor $\hat{c}$ délky $n$: $\hat{c} = c P^{-1}$.
    \item Vektor $\hat{c}$ se dekóduje zvoleným kódem na vektor $\hat{m}$ \\
        $\hat{m} = Dek_{G}\left(\hat{c}\right)$
    \item Vypočítá se původní zpráva $m$: $m = \hat{m} S^{-1}$
\end{enumerate}

\subsubsection{Důkaz dešifrování}\label{kap_dukaz_desifrovani}
Důkaz, že výsledkem dešifrování je opět původní zpráva je následující:

\begin{itemize}
    \item V~prvním kroku dešifrovacího algoritmu je možné rozepsat původní
        zprávu~$m$:
        $$ \hat{c} = c P^{-1} = \left( m \hat{G} + z \right) P^{-1} =
        \left(m S G P + z \right) P^{-1} = \hat{c} = m S G + z P^{-1} $$
    \item Zavedeme substituci $\hat{m} = m S$ a $\hat{z} = z P^{-1}$, potom
        $$ \hat{c} = m S G + z P^{-1} = \hat{m} G + \hat{z} $$
        Z~poslední rovnosti je vidět, že dekódováním je získán vektor $\hat{m}$,
        neboť $\hat{z}$ je vektor s~\emph{Hammingovou vahou} maximálně $t$
        (matice $P$ jen přehází jednotlivé bity vektoru $z$).
        $$ Dek_{G}\left(\hat{c}\right) = \hat{m} $$
    \item V~posledním kroku stačí opět dosadit výše použitou substituci:
        $$ \hat{m} S^{-1} = m S S^{-1} = m $$
\end{itemize}

Dešifrováním je tedy získána původní zpráva $m$.

% --------------------------------------------------------------------
\subsection{Základní vlastnosti kryptosystému}
V~této kapitole jsou probrány základní fakta a vlastnosti \emph{kryptosystému}.
Jsou zde popsány způsoby uložení a velikost klíčů a hlavní výhody a nevýhody
použití \emph{McEliece}.

\subsubsection{Předpočítané matice}
Je vidět, že původní matice $S$ a $P$ se ve výpočtu nepoužívají a pro
dešifrování jsou potřeba pouze jejich \emph{inverze}. Je tedy možné tyto matice
předpočítat a \emph{soukromý klíč} je tak trojice kód s~generující maticí $G$,
matice $S^{-1}$ a matice~$P^{-1}$.

\subsubsection{Velikost klíčů}
Největší nevýhodou \emph{kryptosystému McEliece} je velikost klíčů. Již
v~původním článku jsou navrhovány parametry $n=1024$, $k=524$ a $t=50$\footnote{
    Jak bude zmíněno dále, velikost těchto parametry je pro dnešní použití
    nedostatečná.
}. Za použití těchto parametrů má matice $S$ (respektive její inverze)
$274576$\;b $\approx 268$\;kb a (inverze) matice $P$ $1048576$\;b $= 1$\;Mb.

Matice $P$ je ve skutečnosti velmi \emph{řídká} -- každý \emph{řádek}
(respektive i \emph{sloupec}) obsahuje pouze jednu jedničku, jinak je nulová. Je
to permutační matice a lze tak uchovat ve formě $\log_2 n$ $n$-bitových indexů.
Pro výše zmíněné hodnoty je to $10240$\;b $=10$\;kb.

% TODO odkaz na velikost kódu
% $3 m 2^m + (1-m)mt + m + 1 $
Při použití \emph{binárních Goppa kódů} s~těmito parametry je potřeba k~uložení
informace o~použitém kódu $\approx 26$\;kb. Celkem se jedná o~přibližně
$300$\;kb dat pro uložení soukromého klíče

Pro uložení \emph{veřejného klíče} (matice $\hat{G}$) je třeba $536576$\;b
$=524$\;kb dat.

Metody snížení velikosti klíčů \emph{kryptosystému McEliece} jsou jedním
z~hlavních překážek pro rozšíření algoritmu a také jedním z~hlavních cílů
zkoumání tohoto \emph{kryptosystému} a věnuje se jim
kapitola\ref{kap_snizeni_velikosti_klicu}.

\subsubsection{Rychlost algoritmů}
Naopak jednou z~největších výhod algoritmu \emph{McEliece} je rychlost algoritmů
pro šifrování i dešifrování. Šifrování je prosté násobení matice s~vektorem, což
je jednoduchá operace, kterou je navíc možné provádět paralelně či efektivně
implementovat v~hardwaru. Dešifrování používá též násobení matic, ale složitější
operace je dekódování vektoru $\hat{m}$.

\textsc{TBA}
% TODO citace nějakých paralelních násobení, efektivních zpracování a
% asymptotických složitostí

% --------------------------------------------------------------------
\subsection{Bezpečnost kryptosystému}
Již v~původním článku \cite{McEliece} \emph{McEliece} zmiňuje dva možné útoky na
navržený kryptosystém.
\begin{enumerate}
    \item získání \emph{soukromého} klíče ze znalosti \emph{veřejného}
    \item získání $m$ bez nutnosti znát \emph{soukromý} klíč
\end{enumerate}

Nicméně je dobré již na tomto místě zmínit, že existují útoky využívající
strukturu použitého kódu (tomuto tématu se věnuje
kapitola~\ref{kap_utoky_na_strukturu_kodu}).

\subsubsection{Získání soukromého klíče}
U~prvního způsobu je v~článku zmíněno, že je třeba rozložit $\hat{G}$ na $G$,
$S$ a $P$.  Matici $\hat{G}$ je sice možné dekomponovat, ale množství
jednotlivých matic je pro velká $n$ a $k$ obrovské, a získat tak původní matice
hrubou silou je \emph{neschůdné}\footnote{
    Např. jen počet možných \emph{permutačních matic} je $n!$. Počet
    \emph{generujících} matic závisí na zvoleném kódu.
    % TODO citace?  Počet regulárních matic nad $GF(2)$ je
    % $ \prod\limits_{i=0}^{k-1}(2^k - 2^i) $, což je přibližně jedna ze tří
    % $k \cdot k$ matic.
}.


\subsubsection{Získání původní zprávy}
Druhý způsob znamená dekódovat původní zprávu $m$ z~přijaté zprávy $c$,
která navíc obsahuje chybový vektor. Provést toto dekódování bez znalosti
použitého kódu je \emph{NP-těžký} problém \cite{berlekamp}.

\paragraph{Naznačení problému} \hfil \\

V~případě, že by byl chybový vektor \emph{nulový}, platila by rovnost
$c = m\hat{G}$. Výběrem $k$ \emph{dimenzí} vznikne $\hat{G}_k$~a~$c_k$
z~matice~$\hat{G}$ a~vektoru~$c$. Pokud je $\hat{G}_k$ regulární, lze řešit
soustavu $k$ nerovnic pro $k$ neznámých ($m_i$) v~polynomiálním (!) čase
$O\left(k^3\right)$:
$$c_k = m \hat{G}_k$$

Za použití šifrovacího algoritmu \emph{McEliece} je vektor $c$ \uv{zakrytý}
náhodným chybovým vektorem $z$ \emph{Hammingovy váhy} $t$. Potom
pravděpodobnost, že $c_k$ (ve výběru $k$ dimenzí) je bez chyby je
$\left(1-\frac{t}{n}\right)^k$ \cite{McEliece}. Pro $O\left(k^3\right)$ operací
% TODO je ta pravděpodobnost správně?
pro vyřešení jedné soustavy rovnic je to přibližně:
$$ O\left( \frac{n^3}{\left(1-\frac{t}{n}\right)^k} \right) =
O\left( n^3 \left(\frac{n}{n-t}\right)^k \right)$$

Zlomek $\frac{n}{n-t}$ je jistě větší než $1$, tudíž pro velká $k$ výrazně
převyšuje druhý činitel a jedná se o~\emph{NP-těžký} problém.

Navíc není jasné, \emph{které} z~nalezených řešení odpovídá původní zprávě $m$.

% ====================================================================
\section{Niederreiterovo schéma}
V~roce 1986 publikoval \emph{Harald Niederreiter} v~\cite{Niederreiter}
kryptosystém s~veřejným klíčem využívající stejných principů jako kryptosystém
\emph{McEliece}. Tento kryptosystém je též založený na \emph{lineárních kódech}
a jeho bezpečnost též stojí na problému dekódování neznámého kódu. Na rozdíl
však od kryptosystému \emph{McEliece} používá k~sestrojení klíčů
\emph{kontrolní} matici místo matice \emph{generující}.

% --------------------------------------------------------------------
\subsection{Generování klíčů}
Generování klíčů probíhá následovně:
\begin{enumerate}
    \item Zvolí se \emph{lineární kód} $(n,k)$, opravující $t$ chyb
        s~odpovídající $(n-k) \times n$ \emph{kontrolní maticí}~$H$.
    \item Vygeneruje se \emph{náhodná} $(n-k) \times (n-k)$ \emph{regulární}
        matice $S$.
    \item Vygeneruje se \emph{náhodná} $n \times n$ \emph{permutační}
        matice~$P$.
    \item Vypočítá se $(n-k) \times n$ matice $\hat{H} = S H P$.
\end{enumerate}

Potom čísla $k$, $n$ a $t$ jsou \emph{veřejné parametry} systému, matice
$\hat{H}$ je \emph{veřejný klíč} a kód s~\emph{kontrolní} maticí $H$ a matice
$S$ a $P$ jsou \emph{soukromý klíč}.


% --------------------------------------------------------------------
\subsection{Algoritmy pro šifrování a dešifrování}
\subsubsection{Šifrování}
Šifrování zprávy probíhá následujícím způsobem:
\begin{enumerate}
    \item Zpráva $m$ dlouhá $n$ bitů s~\emph{Hammingovou vahou} maximálně $t$.
        Tato zpráva reprezentuje \emph{chybový vektor} pro použitý kód.
    \item Šifrový text $c$ (délky $n-k$) se spočte jako \emph{syndrom} zprávy
        $m$ (respektive chyby) za použití matice $\hat{H}$: $c = m \hat{H}^T$.
\end{enumerate}

\paragraph{Poznámka} \hfil \\
Chybový vektor $m$ požadované délky $n$ a \emph{Hammingovy váhy} $t$ lze
získat \emph{zakódováním}\footnote{
    Zde nejsou na mysli samoopravné kódy, ale pouze jednoznačné zakódování
    zprávy.
} původní zprávy k~zašifrování. Je vidět, že možných zpráv je pro $t \ll n$
řádově méně než všech možných vektorů délky $n$. Způsob zakódování bude probírán
níže při popisu získání \emph{elektronického podpisu} pomocí tohoto
\emph{kryptosystému}.



\subsubsection{Dešifrování}
Obdržená šifrová zpráva $c$ se dešifruje následujícím způsobem:
\begin{enumerate}
    \item Vypočte se vektor $\hat{c}$ délky $n-k$:
        $\hat{c} = c \left(S^T\right)^{-1} $
    \item Pomocí dekódovacího algoritmu použitého kódu se z~$\hat{c}$ získá
        chybový vektor $\hat{m}$ (délky $n$).
    \item Původní zpráva $m$ se získá výpočtem
        $m = \hat{m} \left(P^T\right)^{-1}$
\end{enumerate}


\paragraph{Poznámka} \hfil \\
Stejně jako je tomu u~\emph{kryptosystému McEliece}, je možné hodnoty
$\left(P^T\right)^{-1}$ a $\left(S^T\right)^{-1}$ předpočítat. Navíc inverzi
$P$ je opět možné uložit jako $\log_2 m$ $n$-bitových hodnot, jelikož se jedná
o~permutaci. Soukromý klíč je tak trojice kód s~kontrolní maticí $H$,
matice $\left(P^T\right)^{-1}$ a matice $\left(S^T\right)^{-1}$.


\subsubsection{Důkaz dešifrování}
Důkaz, že výsledkem dešifrování je opět původní zpráva je následující:

\begin{itemize}
    \item V~prvním kroku dešifrovacího algoritmu je možné výpočet rozepsat
        následujícím způsobem:
    $$ \hat{c} =   c \left(S^T\right)^{-1} =
                    m \hat{H}^T \left(S^T\right)^{-1} =
                    m P^T H^T S^T \left(S^T\right)^{-1} =
                    m P^T H^T
    $$
    \item Zavedeme substituci $\hat{m} = m P^T$, potom $\hat{c} = \hat{m} H^T$,
        což odpovídá výpočtu \emph{syndromu} pro použitý kód. Jelikož $\hat{m}$
        je pouze \emph{permutovaná} původní $m$, má \emph{Hammingovu váhu} $t$
        a pomocí dekódovacího algoritmu získáme $\hat{m}$ jako \emph{chybový
        vektor}.
    \item Nakonec se jen vynásobí inverzí matice $P^T$

\end{itemize}

% --------------------------------------------------------------------
\subsection{Vlastnosti kryptosystému}
\emph{Niederreiterovo} schéma je variantou asymetrického kryptosystému
založeného na lineárních kódech, jak je použito u~kryptosystému
\emph{McEliece}. Šifrovým textem není zakódované slovo, jak je tomu
u~\emph{McEliece}, nýbrž \emph{syndrom} chybového vektoru, který je možné
dekódovat pouze za znalosti skrytého lineárního kódu.

V~\cite{XingLi} byla dokázána ekvivalence složitosti prolomení tohoto
kryptosystému s~kryptosystémem \emph{McEliece} a další informace jsou k~nalezení
v~článku~\cite{Niederreiter}.



% ====================================================================
\section{Elektronický podpis}
V~původním článku od \emph{R. McEliece} \cite{McEliece} bylo zmíněno, že tímto
navrženým kryptosystémem nelze získat schéma pro \emph{elektronický podpis}.
Původní algoritmy byly navržené pouze pro \emph{asymetrické šifrování}.

% --------------------------------------------------------------------
\subsection{Překážky pro použití McEliece pro podepisování}
Aby bylo možné využít algoritmus pro dešifrování jako algoritmus
\emph{podepisování}, bylo by potřeba, aby vektor $c$ (resp. $\hat{c}$) bylo
možné dekódovat na kódové slovo. Nicméně pro jakékoliv použitelné (bezpečné)
parametry je poměr počtu vektorů délky $n$ v~\emph{Hammingově vzdálenosti} $t$
od kódových slov ku všem vektorům délky $n$ téměř nulový. Takový algoritmus pro
podepisování by prakticky vždy selhal a nebylo by možné získat žádný výstup jako
\emph{podpis}.

Například pro navrhované parametry $k=524$, $t=50$ (a $n=1024$) je počet
vektorů do \emph{Hammingovy vzdálenosti} $50$ od všech kódových slov:
$$ 2^{524}\sum_{i = 0}^{50}\left(\!
    \begin{array}{c}
        1024 \\
        i
    \end{array}
\!\right) \approx 2^{808}$$
Počet všech vektorů délky $1024$ je $2^{1024}$. Tedy pravděpodobnost, že vektor
délky $1024$ půjde algoritmem \emph{dekódovat} je přibližně $2^{-216}$
\cite{McEliece}.

Algoritmus \emph{Niederreiter} selhává naprosto stejným stejným způsobem
\cite{Courtois}.

% --------------------------------------------------------------------
\subsection{Schéma pro elektronický podpis}
V~roce 2001 autoři \emph{Courtois} a spol. v~\cite{Courtois} publikovali postup,
jakým lze získat z~kryptosystému založeném na lineárních kódech schéma pro
\emph{elektronický podpis}. Autoři zmiňují, že je možné stejným způsobem využít
i kryptosystém \emph{McEliece}, nicméně kvůli délce výsledného \emph{podpisu} je
mnohem praktičtější využít \emph{Niederreiterovo} schéma.

\subsubsection{Vyhovující parametry }
V~článku je dokázán vzorec pro pravděpodobnost, že náhodný \emph{syndrom} délky
$n-k$ (a při použití \emph{Goppa kódů}) je možné dekódovat je
$$
\mathcal{P} = \cfrac{N_{dekódovatelné}}{N_{celkem}} \approx
\cfrac{\cfrac{n^t}{t!}}{n^t} = \frac{1}{t!}
$$

%Vektorů vyhovující podmínce je
%$$\sum_{i=0}^{t}\left(\!
%\begin{array}{c}
%    n \\
%    i
%\end{array}
%\!\right) $$
%a v případě požadavku na \emph{Hammingovu váhu} právě $t$ je jich pouze
%$$\left(\!\begin{array}{c}
%    n \\
%    t
%\end{array}\!\right)$$ což je mnohem méně než všech možných vektorů $2^n$.

A~tedy závisí pouze na počtu chyb $t$. V~článku je popsána volba parametrů a pro
bezpečnost odpovídající $80$ bitům symetrické šifry jsou zvoleny parametry
$n=2^{16}$ a $t=9$.

Pravděpodobnost, že pro zadané parametry bude náhodný vektor možné dekódovat
jako \emph{syndrom} je $\frac{1}{9!} \approx 2^{-19}$. Pro získání platného
\emph{syndromu} bude tedy nutné v~průměru vygenerovat $2^{19}$ \emph{vektorů}.

\textsc{TBA}
%TODO
%Získání náhodného

% --------------------------------------------------------------------
\subsection{Algoritmus pro podepisování}

% --------------------------------------------------------------------
\subsection{Algoritmus pro ověření}



% ====================================================================
\section{Odolnost vůči kvantovým počítačům}



% ====================================================================
\section{Kryptoanalýza systému McEliece}
% --------------------------------------------------------------------
\subsection{Typy útoků}

% --------------------------------------------------------------------
\subsection{Slabiny systému}

% --------------------------------------------------------------------
\subsection{Existující útoky}
\subsubsection{Útoky na strukturu použitého kódu}\label{kap_utoky_na_strukturu_kodu}

\subsubsection{Malleability}

\subsubsection{Hádání chybových bitů pomocí dešifrovacího orákula}

\subsubsection{Opakované šifrování jedné zprávy}

\subsubsection{Znalost části OT}

\subsubsection{...}



% ====================================================================
\section{Moderní varianty a úpravy}
% --------------------------------------------------------------------
\subsection{Quasi-dyadické Goppa kódy}
% --------------------------------------------------------------------
\subsection{Význam matic $S$ a $P$}
% --------------------------------------------------------------------
\subsection{Metody na snížení velikosti klíčů}\label{kap_snizeni_velikosti_klicu}
% --------------------------------------------------------------------
\subsection{CCA2-odolná varianta}






% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Implementace}\label{kap_implementace}
Pro implementaci kryptosystému \emph{McEliece} v~této práci byl zvolen software
\emph{Wolfram Mathematica} \cite{Mathematica}. Tento software byl zvolen hlavně
díky pohodlnosti některých matematických výpočtů a konstrukcí a také pro
přehlednost výstupů. %TODO

Při implementaci \emph{kryptosystému} se ukázaly nedostatky softwaru
\emph{Mathematica} a bylo nutné zpracovat problematiku (rozšířených)
\emph{konečných těles} a \emph{binárních Goppa kódů}. Tyto dvě oblasti byly
implementovány přímo v~softwaru \emph{Mathematica} tak, aby bylo možné jejich
pohodlné použití i v~jiných oblastech.

Celková práce byla rozdělena do třech ucelených částí -- (binární) \emph{konečná
tělesa}, (ireducibilní) \emph{binární Goppa kódy} a \emph{kryptosystém
McEliece} --, kde každou z~nich lze využít jako \emph{balík} či \emph{knihovnu}
pro další výpočty. Následující kapitoly popisují jednotlivé části.

%\section{Wolfram Mathematica}

% ====================================================================
\section{Binární konečná tělesa}
Tato kapitola pojednává o~implementaci \emph{binárních konečných těles} včetně
jejich \emph{rozšíření}. Jsou zmíněna existující řešení v~softwaru
\emph{Mathematica}, zvolená implementace a popis implementovaných algoritmů.

Ač jsou funkce implementované v~co nejobecnějším pojetí, tak je kladen důraz na
efektivnost výpočtů vzhledem k~\emph{binárním} tělesům -- tedy k~\emph{tělesům}
s~charakteristikou $2$. Pro \emph{tělesa} s~jinou charakteristikou není chování
funkcí definováno.

% --------------------------------------------------------------------
\subsection{Existující řešení}
Pro operace s~\emph{konečnými tělesy} v~softwaru \emph{Mathematica} byly
prostudovány interní funkce pro operace s~polynomy a externí balík
\texttt{FiniteFields}. Vlastnosti těchto řešení jsou popsány v~následujících
kapitolách.

\subsubsection{Operace s~polynomy}
Software \emph{Mathematica} obsahuje funkce pro operace s~polynomy nad reálnými
(případně i komplexními) čísly. Většina těchto funkcí má volitelnou
\emph{možnost}\footnote{
    Anglicky se tento termín v~softwaru \emph{Mathematica}
    nazývá \emph{Option}.
} \emph{Modulus}, díky které lze zajistit, aby operace s~koeficienty byly
prováděny nad celými čísly \emph{modulo} zadané číslo $p$. Tímto způsobem je
možné implementovat operace nad tělesy $GF(p^n)$, nicméně je téměř nemožné tímto
způsobem implementovat \emph{rozšířená tělesa} -- polynomy nad polynomy.

Pro použití těchto funkcí (např. \texttt{ExtendedPolynomialGCD}, je třeba
polynomu v~úplném tvaru $\sum a_i x^i$ -- včetně $x^i$ s~tím, že $x$ musí být
nedefinovaný \emph{symbol}\footnote{
    Jinými slovy proměnná, která nemá definovanou hodnotu.
}. Tento požadavek je celkem nepraktický, protože definování této proměnné
kdekoliv v~programu by vedlo k~nemožnosti použití těchto funkcí. Navíc udržovat
si prvky ve formě např. $x^6 + x^3 + x + 1$ místo $1001011$ není pohodlné.
Další nevýhoda použití polynomů je, že software \emph{Mathematica} vypisuje
polynomy od \emph{nejnižšího} členu po \emph{nejvyšší} (např. $1+x^2+x^4+x^7$),
což je obrácený zápis, než je v~technické literatuře zvykem.

\subsubsection{Balík \texttt{FiniteFields}}
\paragraph{Balík} \emph{Balík} v~softwaru \emph{Mathematica} je soubor
obsahující rozšiřující funkce, které standardně nejsou k~dispozici. Balík je
možné načíst pomocí funkcí \texttt{Needs}, či případně \emph{Get}.

Balík \texttt{FiniteFields} obsahuje základní operace pro práci s~tělesy
$GF(p^n)$. Prvky konečných těles jsou pak určené \emph{seznamem}\footnote{
    \emph{Seznamem} se myslí struktura v~softwaru
    \emph{Mathematica} -- \emph{List}
} koeficientů a \emph{hlavičkou}, která určuje do jakého tělesa prvek patří.
Výhoda tohoto opatření je, že pro sčítání a násobení je pak možné využít
obyčejné symboly operací ($+$, $-$, $*$, $/$) a operace se automaticky provede
v~daném tělese.  Pro parametry $p$ a $n$ je určené jedno těleso $GF(p^n)$
(s~jedním konkrétním ireducibilním polynomem) a \emph{seznam} koeficientů prvku
se opět píše od nejnižšího řádu po nejvyšší (například polynom $x^3 + x + 1$
z~tělesa $GF(2^5)$ je zapsán jako $GF[2,5][\{1,1,0,1,0\}] $).

Funkce z~balíku \texttt{FiniteFields} nejsou dostatečně zdokumentovány, jak
je jinak v~softwaru \emph{Mathematica} zvykem. Nepodařilo se využít funkcí
z~tohoto balíku pro operace s~\emph{rozšířenými tělesy}.

% --------------------------------------------------------------------
\subsection{Zvolené řešení}
Existující řešení pro práci s~\emph{konečnými tělesy} se ukázala jako
nedostačující. Jejich hlavní nevýhodou je nemožnost použití při výpočtech
s~\emph{rozšířenými tělesy}. Proto bylo implementováno vlastní řešení pro práci
s~\emph{konečnými tělesy}.

Při implementaci operací nad \emph{konečnými tělesy} bylo dodržováno následující
jednotné rozhraní:

\begin{itemize}
    \item Prvky \emph{konečných těles} jsou reprezentovány \emph{seznamem}
        koeficientů od nejvyššího po nejnižší. \\ U~\emph{rozšířených těles}
        jsou koeficienty opět prvky konečných těles. \\
        Například polynom $x^3+x+1$ je reprezentován seznamem: $\{1,0,1,1\}$ \\
        a polynom $(y+1)x^2 + (y)$ je reprezentován:
        $\left\{\{1,1\},\{0,0\},\{1,0\}\right\}$

    \item Prvek (seznam koeficientů) může být libovolně dlouhý. V~případě
        potřeby se při výpočtu \emph{redukuje} (ireducibilním) polynomem nebo
        dorovná \emph{nulovými} koeficienty.

    \item Počet koeficientů vnitřních prvků (koeficientů) musí být vždy stejný. \\
        Například prvek $\{\{0,0\},\{1\},\{1,0\}\}$ není dovolený.

    \item Jednotlivým funkcím je kromě operandů předáván též i \emph{modul}
        skládající se z~odpovídajících (ireducibilních) polynomů, včetně
        charakteristiky tělesa. Tento \emph{modul} je definovaný následovně: \\
        Pro tělesa $GF(p^{n_1})$ je \emph{modul} složen z~(ireducibilního)
        polynomu $i_1$ stupně $n_1$ a dané charakteristiky $p$:
        $modul_1 = \left\{i_1,p\right\}$ \\
        Pro rozšířená tělesa se \emph{modul} skládá z~odpovídajícího
        \emph{polynomu} $i_k$ stupně $n_k$ nad tělesem
        $GF( {{p^{n_1}}^{\dots}}^{n_{k-1}} )$ a \emph{modulu vnitřního tělesa}: \\
        $modul_k = \left\{i_k,modul_{k-1}\right\}$.

    \item Všem funkcím se předávají nejdřív \emph{operandy} a poté \emph{modul}.\\
        Například pro prvky $a,b\in GF(p^{\ldots})$, $m\in\mathbb{N}$
        a odpovídající $modul$: \\
        \hspace*{0.6cm}$krat[a,b,modul]$ \\
        \hspace*{0.6cm}$inverze[a,modul]$ \\
        \hspace*{0.6cm}$mocnina[a,m,modul]$ \\
        \hspace*{0.6cm}\ldots

    \item Pro implementaci operací v~\emph{prvotělesech} (tělesech $GF(p^n)$)
        jsou použité vnitřní funkce softwaru \emph{Mathematica} pro práci
        s~\emph{polynomy}. Implementované funkce pro \emph{prvotělesa} tedy
        zpravidla obsahují převod ze \emph{seznamu} čísel na \emph{polynom},
        zavolání vnitřní funkce pro \emph{polynomy} a převodu zpět na
        \emph{seznam} koeficientů. Díky těmto vnitřním funkcím je docíleno
        rychlejšího výpočtu, než kdyby byla použita vlastní implementace nad
        \emph{seznamy} celých čísel.

    \item Pro implementaci operací v~\emph{rozšířených tělesech} byly
        implementovány jednotlivé algoritmy operací (popsané níže), jelikož
        nebylo možné použít pro tyto operace vnitřní funkce softwaru
        \emph{Mathematica}. Funkce nad \emph{rozšířenými tělesy} zpravidla
        volají odpovídající funkce ve vnitřních tělesech (například násobení
        jednotlivých \emph{koeficientů}).

\end{itemize}

Tato pravidla umožňují pohodlný, jednotný a \emph{rekurzivní} přístup
k~jednotlivým prvkům a voláním funkcí (druhá složka \emph{modulu} je
\emph{modul} \emph{vnitřního tělesa}, prvky \emph{polynomu} jsou opět
\emph{polynomy}, \ldots).

% --------------------------------------------------------------------
\subsection{Implementace operací}
V~následujících kapitolách je popsána implementace hlavních operací
v~\emph{konečných tělesech} a použitých algoritmů. Pro další informace je
doporučeno nahlédnout do zdrojového kódu a příkladů použití.

V~níže uvedených pseudokódech se používá některých prvků ze syntaxe softwaru
\emph{Mathematica}:

\begin{table}[h!]
    \centering
    \begin{tabular}{l  l}
        Zápis               & Význam                                            \\
        \hline
        \texttt{foo[bar]}   & Volání funkce \emph{foo} s~argumentem \emph{bar}  \\
        \texttt{ham[[i]]}   & \emph{i}-tý prvek seznamu (pole) \emph{ham}       \\
    \end{tabular}
    \caption{Prvky syntaxe jazyka softwaru \emph{Mathematica}}
\end{table}

\subsubsection{Sčítání}
Jelikož operace sčítání se v~jakémkoliv \emph{tělese} provádí po jednotlivých
koeficientech \emph{modulo} $p$, je tato funkce jediná volána místo celkového
modulu pouze se zadanou charakteristikou $p$.

Pro \emph{rozšířená tělesa} funkce rekurzivně volá stejnou operaci sčítání na
jednotlivé koeficienty zadaných polynomů až na úroveň \emph{prvotěles} --
obyčejných jednorozměrných seznamů. Pro \emph{prvotělesa} funkce používá
obyčejné sčítání dvou seznamů modulo $p$.

\begin{algoritmus}[h!]
    \caption{Sčítání polynomů}
    \begin{algorithmic}[1]
     \Function{plus[$a$,$b$,$p$]}{}\Comment{Pro $GF(p^n)$, $p$ je prvočíslo}
        \State \Return $Mod[a+b,p]$
     \EndFunction
    \end{algorithmic}
    \begin{algorithmic}[1]
     \Function{plus[$a$,$b$,$p$]}{}\Comment{Pro $GF(q^n)$, $q$ je $p^{\dots}$}
        \For{$ i \gets 1\dots Length[a] $}
            \State $c[[i]] \gets plus[a[[i]],b[[i]],p]$
        \EndFor
        \State \Return $c$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\subsubsection{Redukce polynomu}
Redukce polynomu (neboli \emph{modulo} polynom) se používá ve většině dalších
funkcí. Tato funkce se volá se dvěma parametry -- prvkem $a$ a polynomem
(\emph{modulem}) $m$. Funkce vrátí zbytek polynomu $a$ po dělení polynomem $m$.

Redukce polynomu pro \emph{rozšířená tělesa} je inspirovaná \emph{Comb metodou}
z~\cite{Paar_Efficient}. K~původnímu prvku $a$ se opakovaně přičítá (od
nejvyššího řádu) patřičný násobek \emph{polynomu} $m$ tak, aby se daný
koeficient $a_i$ rovnal nule (viz příklad níže).

Pro \emph{prvotělesa} se používá interní funkce \texttt{PolynomialMod}

\begin{algoritmus}[h!]
    \caption{Redukce polynomu v~tělese s~charakteristikou $2$}
    \begin{algorithmic}[1]
     \Function{redukuj[ $a$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \State $ l_a \gets stupen[a] + 1 $
            \Comment{Délka redukovaného polynomu}
        \State $ l_m \gets stupen[m]$
            \Comment{Výsledná délka redukovaného polynomu}

        // Převedení $m$ na \emph{monický} polynom
        \State $ koef \gets inverze[ m[[1]], modul_{vnitrni} ] $
            \Comment{Inverze nejvyššího koeficientu}
        \State $ m \gets krat[ koef, m, modul_{vnitrni} ] $
            \Comment{Násobení skalárem}

        \hfil
        \State $ m \gets PadRight[ m, l_a - l_m ] $
            \Comment{Natáhnutí polynomu na délku $a$}

        \For{$ i \gets 1 \ldots l_a - l_m $}
            \State $ s \gets krat[ a[[i]], m, modul_{vnitrni} ] $
                \Comment{Skalární násobek}
            \State $ a \gets plus[ a, s, 2 ] $
                \Comment{Odečtení v~binárním tělese}
            \State $ m \gets RotateRight[m] $
                \Comment{Posunutí redukovaného polynomu}
        \EndFor

        \hfil
        \State \Return $a$

     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\paragraph{Příklad} Redukce polynomu $ x^{12} + x^8 + x^7 + x^5 + x^4 + x^3 + 1 $
polynomem $ x^4 + x + 1 $ (nad tělesem $GF(2)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{align*}
& 1000110111001 \mod 10011: \\
& \arraycolsep=1pt
\begin{array}{*{13}{l}}
        1 &  0 &  0 &  0 &  1 &  1 &  0 &  1 &  1 &  1 &  0 &  0 &  1   \\
    \hline
        1 &  0 &  0 &  1 &  1 & \0 & \0 & \0 & \0 & \0 & \0 & \0 & \0   \\
       \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0 & \0 & \0 & \0   \\
       \0 & \0 & \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0 & \0   \\
       \0 & \0 & \0 & \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0   \\
    \hline
          &    &    &    &    &    &    &    &    &  1 &  1 &  0 &  1   \\
\end{array}
\end{align*}


\subsubsection{Násobení}
Výsledkem násobení dvou polynomů $a$ a $b$ stupně $n$ a $m$ je polynom $c$
stupně $n+m$. Násobení je implementováno tak, že k~výsledku $c$ (na počátku
je to nulový polynom) se postupně přičítá skalární násobek polynomu $b$
koeficienty polynomu $a$, který je zároveň \emph{posunutý} o~patřičný počet
pozic. Využívá se zde faktu, že násobení libovolného \emph{polynomu} $A(x)$
a $x^i$ je posunutí koeficientů polynomu $A$ o~$i$ pozic doleva. Výsledný
polynom $c$ je následně \emph{redukován} zadaným modulem (viz výše).

Pro \emph{prvotělesa} se používá obyčejného násobení dvou \emph{polynomů}
a následné \emph{redukce} \emph{modulem}.

\begin{algoritmus}[h!]
    \caption{Násobení prvků}
    \begin{algorithmic}[1]
     \Function{krat[ $a$, $b$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \State $ p \gets charakteristika[ modul ] $
            \Comment{Charakteristika tělesa}

        // Natažení na výslednou délku
        \State $ b \gets PadLeft[ b, stupen[a] + stupen[b] + 1 ] $
        \State $ c \gets nulovyPolynom[\ldots ] $
            \Comment{Nulový polynom nad vnitřním tělesem}

        \hfil
        \For{$ i \gets stupen \ldots 1 $}
            \State $ s \gets krat[ a[[i]], b, modul_{vnitrni} ] $
                \Comment{Skalární násobek}
            \State $ c \gets plus[ c, s, p ] $
            \State $ b \gets RotateLeft[b] $
                \Comment{Posunutí přičítaného polynomu}
        \EndFor

        \hfil
        \State \Return $redukuj[c]$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\paragraph{Příklad} Násobení polynomu $x^3+x+1$ polynomem
$x^4+x^2+2x+1$ (nad tělesem $GF(3)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{align*}
& 1011 \cdot 10121: \\
& \arraycolsep=1pt
\begin{array}{r *{8}{l}}
        1 (x^4) &  1 &  0 &  1 &  1 & \0 & \0 & \0 & \0 \\
        0 (x^3) & \0 &  0 &  0 &  0 &  0 & \0 & \0 & \0 \\
        1 (x^2) & \0 & \0 &  1 &  0 &  1 &  1 & \0 & \0 \\
        2 (x^1) & \0 & \0 & \0 &  2 &  0 &  2 &  2 & \0 \\
        1 (x^0) & \0 & \0 & \0 & \0 &  1 &  0 &  1 &  1 \\
    \hline
                & 1 & 0 & 2 & 0 & 2 & 0 & 0 & 1
\end{array}
\end{align*}

\subsubsection{Inverze}
Výpočet multiplikativní \emph{inverze} je implementován pomocí \emph{rozšířeného
Euklidova algoritmu}. Tento algoritmus se často vizualizuje jako výpočet tabulky
po řádkách (viz níže). Ve skutečnosti však pro výpočet dalšího řádku stačí
pracovat s~hodnotami dvou řádků předešlých. Proto si není nutné udržovat
v~paměti celou tabulku, ale stačí si udržovat hodnoty dvou řádků a po výpočtu
třetího hodnoty posunout.

Výpočet hodnot dalšího řádku tabulky probíhá následovně:
\begin{itemize}
    \item Hodnoty předchozích řádků jsou:\\
        \hspace*{0.6cm}Polynomy $p_{i-2}$ a $p_{i-1}$ (na začátku inicializovány
            na ireducibilní polynom $m$ a \emph{prvek}, ke kterému je hledaná
            inverze). \\
        \hspace*{0.6cm}Polynomy $k_{i-2}$ a $k_{i-1}$ (na začátku inicializovány
            na $0$ a $1$, respektive \emph{nulový} a \emph{jednotkový
            polynom}).

    \item Je spočítán \emph{podíl} $q$ a zbytek $p_i$ pomocí tzv. \emph{dlouhého
        dělení} polynomu $p_{i-2}$ polynomem $p_{i-1}$.

    \item Je spočítán \emph{polynom} $k_i = k_{i-2} - q \cdot k_{i-1} $

    \item Tyto kroky se opakují, dokud není získán polynom $p_i$ stupně $0$
        (jinými slovy jediný prvek vnitřního tělesa).

    \item Výsledná \emph{inverze} se získá jako skalární násobek \emph{polynomu}
        $k_i$ inverzí (posledního) \emph{koeficientu} polynomu $p_i$\footnote{
            Zde je vidět, že pro výpočet inverze v~tělese $GF(q^n)$ je třeba
            vypočítat inverzi v~tělese $GF(q)$.
        }.
\end{itemize}

Inverze v~\emph{prvotělese} je implementovaná pomocí interní funkce
\texttt{PolynomialExtendedGCD}.

\begin{algoritmus}[h!]
    \caption{Inverze prvků -- \emph{Rozšířený Euklidův algoritmus}}
    \begin{algorithmic}[1]
     \Function{inverze[ $prvek$, $modul:\left\{ m, modul_{vnitrni} \right\}$ ]}{}
        \State $ A \gets m $; $ B \gets prvek $

        // Inicializace na \emph{jednotkový} resp. \emph{nulový} polynom z~tělesa
        \State $ k_A \gets nulovyPolynom[\ldots] $;
            $ k_B \gets jednotkovyPolynom[\ldots] $
        \While{$stupen[B] \neq 0 $}

            // Výpočet $q$ a $C$ pomocí dlouhého dělení v~jednom kroku
            \State $ q   \gets A/B $; $ C   \gets A \mod B $
            \State $ k_C \gets k_A - krat[ q, k_B, modul ] $
            \State $ A \gets B$; $k_A \gets k_B$
            \State $ B \gets C$; $k_B \gets k_C$
        \EndWhile

        // Výpočet koeficientu ve vnitřním tělese
        \State $koef \gets inverze[ Last[C], modul_{vnitrni} ]$
        \State \Return $krat[ koef, k_C, modul_{vnitrni} ]$\Comment{Násobení skalárem}
     \EndFunction
    \end{algorithmic}
    \label{alg_eea}
\end{algoritmus}


\paragraph{Příklad} \emph{Rozšířený Euklidův algoritmus} pro výpočet
\emph{inverze} polynomu $x^3+x^2+1$ \emph{modulo} $x^6+x+1$ (nad tělesem
$GF(2)$):

\begin{center}
    \begin{tabular}{r|r r r}
          Podíl &    Zbytek &       Koeficienty \\
        \hline
        \hline
                & $1000011$ &       $0$ &   $1$ \\
                &    $1101$ &       $1$ &   $0$ \\
        \hline
         $1110$ &     $101$ &   $-1110$ &   $1$ \\
           $11$ &      $10$ &   $10011$ & $-11$ \\
           $10$ &       $1$ & $-101000$ & $111$
    \end{tabular}
\end{center}
$ \Rightarrow \left|1101^{-1}\right|_{1000011} = 101000 $

\paragraph{Poznámka} Poslední sloupec tabulky se v~algoritmu nepočítá, je zde
uveden pouze pro úplnost.


\subsubsection{Druhá mocnina}
Pro prvky tělesa s~\emph{charakteristikou} $2$ Je výhodné implementovat funkci
\uv{na druhou} díky následujícímu tvrzení:


\begin{tvrzeni}
    Nechť $A=(a_n \dots a_2 a_1 a_0)$ je prvek tělesa
    s~\emph{charakteristikou} $2$, potom platí:
    $$ A^2 = (a_n^2 0 \dots 0 a_2^2 0 a_1^2 0 a_0^2) $$
\end{tvrzeni}

\paragraph{Důkaz}
\begin{align*}
    A(x)     &=  a_n x^n + \dots + a_2 x^2 + a_1 x + a_0 \\
    {A(x)}^2 &=  (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0)\cdot(a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) \\
             &= a_n x^n   \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {} \\
             & \qquad \vdots \\
             &  {} + a_2 x^2   \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {} \\
             &  {} + a_1 x \, \:  \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {} \\
             &  {} + a_0 \quad \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) \\
             &= a_n^2 x^{2n}    + \dots + a_n a_2 x^{n+2} + a_n a_1 x^{n+1} + a_n a_0 x^n + {} \\
             & \qquad \vdots \\
             &  {} + a_n a_2 x^{n+2} + \dots + a_2^2 x^4       + a_2 a_1 x^3     + a_2 a_0 x^2 + {} \\
             &  {} + a_n a_1 x^{n+1} + \dots + a_2 a_1 x^3     + a_1^2 x^2       + a_1 a_0 x   + {} \\
             &  {} + a_n a_0 x^n     + \dots + a_2 a_0 x^2     + a_1 a_0 x       + a_0^2            \\
             &= a_n^2 x^{2n} + \dots  + 2 ( a_3 a_0 + a_2 a_1 ) x^3  + 2 ( a_2 a_0 ) x^2 + a_1^2 x^2 + 2 ( a_1 a_0 ) x + a_0^2  \\
             &= \sum_{i=0}^{n} a_i^2 x^{2i} + 2 \sum_{i=1}^{n+1}\sum_{\substack{
    j<k \\ j+k = i }} a_j a_k &\\
             &= \sum_{i=0}^{n} a_i^2 x^{2i}
    \hspace{2.5cm} \cong (a_n^2 0 \dots 0 a_2^2 0 a_1^2 0 a_0^2)
%             &= a_n^2 x^{2n} + \dots + a_2 x^4 + a_1^2 x^2 + a_0^2  \\
\end{align*}

S~využitím tohoto tvrzení je realizace funkce na počítání druhé mocniny
triviální:
\begin{itemize}
    \item Provedení druhé mocniny všech koeficientů.
    \item Proložení koeficientů polynomu nulovými koeficienty.
    \item Redukování polynomem (viz výše).
\end{itemize}

\begin{algoritmus}[h!]
    \caption{Umocňování na druhou v~tělese s~charakteristikou $2$}
    \begin{algorithmic}[1]
     \Function{naDruhou[ $a$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \For{$ i \gets 1 \dots Length[i]$}
            \State $ a[[i]] \gets naDruhou[ a[[i]], modul_{vnitrni} ] $
        \EndFor
        \State $ nula \gets nulovyPolynom[ \ldots ]$
            \Comment{Odpovídající nulový koeficient}
        \State $ a \gets Riffle[ a, nula ] $
            \Comment{Proloží koeficienty prvkem $nula$}
        \State \Return $ redukujPolynom[ a, modul ] $
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\subsubsection{Mocnění}
Mocnění \emph{polynomů} je implementováno pomocí algoritmu
\emph{Square-and-Multiply} (\emph{SM}). Algoritmus využívá faktu, že libovolnou
mocninu lze rozložit na součin mocnin čtverců ($^2$,$^4$,$^8$,\dots). Konkrétně
byla implementována varianta provádějící výpočet od nejvíce významného bitu
exponentu\footnote{
    Uváděna jako \emph{MSB} -- z~anglického \emph{most significant bit}
}. Algoritmus má vstupy polynom $a$ a exponent $e$. Exponent se vyjádří jako
číslo v~\emph{binární} soustavě a poté algoritmus provádí cyklus přes bity
tohoto rozvoje. V~každém kroku se mezivýsledek umocní na druhou a v~případě, že
je odpovídající bit exponentu $1$, přinásobí se původní číslo $a$.


\begin{algoritmus}[h!]
    \caption{Umocňování prvku $a^e \mod modul$ -- \emph{Square-and-Multiply}}
    \begin{algorithmic}[1]
     \Function{umocni[ $a$, $e$, $modul$ ]}{}
        \If{$ e = 0 $}
            \State \Return $nulovyPolynom[\ldots]$
                \Comment{Nulový prvek tělesa}
        \EndIf
        \State $ rozvoj \gets IntegerDigits[ e, 2 ] $
            \Comment{Binární rozvoj exponentu}
        \State $ c \gets a $
            \Comment{$rozvoj[[1]]$ je vždy $1$}
        \For{$ i \gets 2 \ldots Length[rozvoj] $}
            \State $ s \gets naDruhou[ c, modul ] $
            \State $ m \gets krat[ s, a, modul ] $
            \If{$ rozvoj[[i]] = 0 $}
                \State $ c \gets s $
            \Else
                \State $ c \gets m $
            \EndIf
        \EndFor
        \State \Return $c$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}


\paragraph{Poznámka} Takto implementovaný algoritmus je zranitelný vůči odběrové
a časové analýze. Pro odolnou implementaci je nutné počítat násobek \emph{vždy}
a pokud je daný bit exponentu $1$, přiřadit násobek do mezi výpočtu. Pseudokód
i reálná implementace je prováděna tímto (bezpečným) způsobem.

\paragraph{Příklad} \emph{Square-and-Multiply} pro výpočet
$\left(x^3+1\right)^{26}$ \emph{modulo} $x^6+x+1$ (nad tělesem $GF(2)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{center}
    \begin{tabular}{c|r|l|r|r}
        \multirow{2}{*}{Op.} & \multicolumn{2}{c}{Mocnina} & \multicolumn{1}{c}{\multirow{2}{*}{Výpočet}} & \multirow{2}{*}{Výsledek} \\
                &  dek. & bin.    &                   &              \\
        \hline
        \hline
                & $  1$ & $1    $ &                   & $ 1001$      \\
        \hline
    \textbf{S}  & $  2$ & $1    $ & $    1\00\00\01 $ & $   10$      \\
    \textbf{M}  & $  3$ & $11   $ & $ 10 \cdot 1001 $ & $10010$      \\
        \hline
    \textbf{S}  & $  6$ & $110  $ & $ 1\00\00\01\00 $ & $ 1000$      \\
        \hline
    \textbf{S}  & $ 12$ & $1100 $ & $    1\00\00\00 $ & $   11$      \\
    \textbf{M}  & $ 13$ & $1101 $ & $ 11 \cdot 1001 $ & $11011$      \\
        \hline
    \textbf{S}  & $ 26$ & $11010$ & $     1\01\00\01\01 $ & $ 1010$      \\
    \end{tabular}
\end{center}
$ \Rightarrow \left|1001^{26}\right|_{1000011} = 1010 $

% --------------------------------------------------------------------
\subsection{Možná zlepšení}
V~této kapitole jsou nastíněny možná zlepšení implementace, která
zrychlují výpočet některých operací.

\subsubsection{Logaritmické tabulky}
Pro zrychlení výpočtu násobení a mocnin prvku lze v~\emph{konečném tělese}
využít faktu, že vždy existuje \emph{primitivní prvek} a převádět tak operace
v~tělese na operace s~celými čísly.

\begin{definice}
    Nechť $\alpha$ je \emph{generátor} \emph{multiplikativní grupy} tělesa $F$.
    Potom říkáme, že $\alpha$ je \emph{primitivní prvek} tělesa $F$.
\end{definice}

\paragraph{Důsledek} Každý prvek tělesa $F$ -- kromě \emph{nulového} prvku
\emph{aditivní grupy} -- lze vyjádřit jako $\alpha^i$ pro nějaké $i$.

Důkaz plyne přímo z~definice.

Násobení dvou prvků $a = \alpha^{i_a}$ a $b = \alpha^{i_b}$ tak lze převést na
součet mocnin \emph{primitivního prvku}:
$$ a \cdot b = \alpha^{i_a} \cdot \alpha^{i_b} = \alpha^{i_a + i_b} $$

Podobným způsobem je možné zjednodušit umocňování prvku:
$$ a^e = \left(\alpha^i\right)^e = \alpha^{i e} $$

V~obou případech je samozřejmě možné použít \emph{Eulerovu větu} a mocniny
redukovat \emph{modulo} $N$, kde $N$ je počet prvků \emph{multiplikativní grupy
tělesa} ($N=p^n-1$ pro těleso $GF(p^n)$). Jakoukoliv operací násobení a mocnění
se získá prvek $\alpha^{n_c}$, kde $n_c$ je celé číslo v~rozsahu od $0$ do
$N-1$.

Reprezentací prvků pomocí odpovídajících mocnin \emph{primitivního prvku} je tak
možné vyhnout se násobení a umocňování prvků v~tělese a nahradit ho sčítáním a
násobením celých čísel, což je řádově jednodušší. V~případě sčítání prvků
v~tělese je však nutné mít jejich standardní reprezentaci (seznam koeficientů),
jelikož se sčítání provádí po jednotlivých koeficientech, respektive bitech.
Není možné nahradit sčítání dvou prvků jiné operaci s~mocninami
\emph{primitivního prvku}.

Pro použití tohoto zrychlení výpočtů je tak nutné připravit v~paměti programu
překladové \emph{log}- a \emph{antilogaritmické} tabulky pro překlad prvků
z~jedné reprezentace na druhou.

Ač se tak získá podstatné zrychlení výpočtů v~tělese, existuje několik nevýhod
tohoto přístupu:

\begin{itemize}
    \item Je nutné nalézt \emph{primitivní prvek tělesa}.

    \item Je nutné vygenerovat a uchovat v~paměti počítače obě tabulky pro
        překlad.
        \begin{itemize}
            \item Tato tabulka lze implementovat pomocí obyčejného pole či
                seznamu, kde se k~danému indexu v~seznamu vyskytuje odpovídající
                hodnota.
            \item Pro binární  tělesa $GF(2^m)$ je velikost jedné tabulky
                $O(m 2^m)$ (konkrétně $2^m - 1$ hodnot, kde každá je
                reprezentována $m$ bity).
            \item Jelikož je paměťová náročnost \emph{exponenciální}, je
                možné tyto tabulky uchovávat pouze pro \emph{malá} $m$ (např.
                $8$ či $16$, nikoliv však $1024$).
        \end{itemize}

    \item \emph{Nulový prvek} tělesa není možné žádným způsobem zobrazit jako
        mocninu. Při každé operaci je potřeba s~touto skutečností počítat
        a hlídat jako výjimku.

\end{itemize}


Tohoto vylepšení se dá využít pro operace ve \emph{vnitřním tělese}
$GF(2^m)$, nad kterým jsou postavené polynomy v~\emph{binárních Goppa kódech}.


\subsubsection{Implementace dělení}
Dělení prvkem $b$ v~\emph{konečném tělese} se převádí na násobení $b^{-1}$. Pro
výpočet \emph{podílu} se tak počítá inverze a následně násobek. Je ale možné
implementovat rovnou algoritmus pro dělení.

Algoritmus pro dělení prvku $a$ prvkem $b$ je totožný s~algoritmem pro výpočet
\emph{inverze} prvku $b$ s~tím rozdílem, že je počáteční hodnota koeficientu
$k_b$ (viz \emph{EEA} -- alg. \ref{alg_eea}) nastavena na hodnotu $a$.
%Jelikož průběh algoritmu odpovídá ekvivalentním úpravám rovnic,
%algoritmus skončí s rovnicí:
%
%$$ 1 = (l \cdot a ) \cdot b  + k \cdot m $$
Výsledkem algoritmu pak bude inverze prvku $b$ vynásobená $a$, což přesně
odpovídá výrazu $a/b$.


% ====================================================================
\section{Ireducibilní binární Goppa kódy}

% ====================================================================
\section{McEliece}

% ====================================================================
\section{Měření}




% ====================================================================
% ====================================================================
% ====================================================================
\begin{conclusion}
        %sem napište závěr Vaší práce
\end{conclusion}




% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Prilohy
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%\bibliographystyle{csn690}
%\bibliography{mybibliographyfile}
\begin{thebibliography}{99}

% články, knihy
    \bibitem{McEliece}
        Robert J. \textsc{McEliece}, A~Public-Key Cryptosystem Based on
        Algebraic Coding Theory v~\emph{JPL Deep Space Network Progress Report
        42-44} Jenuary and February 1978, strany 114–116. Dostupné online
        \url{http://ipnpr.jpl.nasa.gov/progress_report2/42-44/44N.PDF}

    \bibitem{Niederreiter}
        Harald \textsc{Niederreiter}. Knapsack-type cryptosystems and
        algebraic coding theory v~\emph{Problems of Control and Information
        Theory 15}, strany 19-34. 1986

    \bibitem{XingLi}
        Yuan \textsc{Xing Li}, Robert H. \textsc{Deng}, Xin \textsc{Mei Wang}.
        On the equivalence of McEliece's and Niederreiter's public-key
        cryptosystems v~\emph{IEEE Transactions on Information Theory}, vol. 40,
        strany 271-273. IEEE, leden 1994. Dostupné online
        \url{http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=272496}

    \bibitem{Berlekamp}
        Elwyn R. \textsc{Berlekamp}, Robert J. \textsc{McEliece}, Henk C. A. van
        \textsc{Tilborg}.  On the Inherent Intractibility v~\emph{IEEE
        Transactions of Information Theory}, vol. IT-24, No. 3, strany 384-386.
        IEEE, květen 1978.

    \bibitem{Courtois}
        Nicolas T. \textsc{Courtois}, Matthieu \textsc{Finiasz}, Nicolas
        \textsc{Sendrier}. How to Achieve a McEliece-Based Digital Signature
        Scheme v~\emph{Advances in Cryptology -- ASIACRYPT 2001}, strany
        157-174. Springer Berlin Heidelberg, 2001. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F3-540-45682-1\_10}

    \bibitem{Paar_Understanding}
        Christof \textsc{Paar}, Jan \textsc{Pelzl}. \emph{Understanding
        Cryptography}: A~Textbook for Students and Practitioners.
        Springer-Verlag Berlin Heidelberg, 2010. Dostupné
        online: \url{https://www.springer.com/us/book/9783642041006}

    \bibitem{Paar_Efficient}
        J. G. \textsc{Merchan}, S. \textsc{Kumar}, C. \textsc{Paar},
        J. \textsc{Pelzl}. Efficient Software Implementation of Finite
        Fields with Applications to Cryptography v~\emph{Acta Applicandae
        Mathematicae: An International Survey Journal on Applying Mathematics
        and Mathematical Applications}, Volume 93, Numbers 1-3, strany  3-32.
        Ruhr-Universitat Bochum, 2006. Dostupné online:
        \url{http://www.emsec.rub.de/research/publications/efficient-software-implementation-finite-fields-ap/}

    \bibitem{ITT} ITT

% přednášky
    \bibitem{FIT_LIN} Přednášky BI-LIN
    \bibitem{FIT_BHW} Přednášky MI-BHW
    \bibitem{FIT_MKY} Přednášky MI-MKY
    \bibitem{FIT_MPI} Přednášky MI-MPI

% software
    \bibitem{Mathematica} Wolfram Mathematica
\end{thebibliography}

\appendix

% ====================================================================
% ====================================================================
\chapter{Seznam použitých zkratek}
% \printglossaries
\begin{description}
        \item[EEA] \emph{Extended Euclidean Algorithm} -- Rozšířený Euklidův algoritmus
        \item[GCD] \emph{Greatest Common Divisor} -- Největší společný dělitel
        \item[GF] \emph{Gallois field} -- konečné těleso
        \item[LSB] Least Significant Bit/Byte -- nejméně významný bit/bajt
        \item[MSB] Most Significant Bit/Byte -- nejvíce významný bit/bajt
        \item[S\&M] algoritmus \emph{Square-and-Multiply}
        %\item[TLS] Three Letter Shortcut
\end{description}

% TODO
%\chapter{Algoritmy}
%\section{ITT}
%TBA

% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Obsah přiloženého CD}

%upravte podle skutecnosti

%TODO
\begin{figure}
        \dirtree{%
                .1 readme.txt\DTcomment{stručný popis obsahu CD}.
                .1 exe\DTcomment{adresář se spustitelnou formou implementace}.
                .1 src.
                .2 impl\DTcomment{zdrojové kódy implementace}.
                .2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
                .1 text\DTcomment{text práce}.
                .2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
                .2 thesis.ps\DTcomment{text práce ve formátu PS}.
        }
\end{figure}

\end{document}

