% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,czech,hidelinks]{FITthesis}[2012/06/26]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage{multirow} % multirow for tabular
\usepackage{graphicx} %graphics files inclusion
\usepackage{amsmath} %advanced maths
\usepackage{amssymb} %additional math symbols

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{dirtree} %directory tree visualisation
% \usepackage{textcomp} % \textcopyleft

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries
\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens
\newcommand{\0}{{\textcolor[gray]{0.80}{0}}}

\newenvironment{algoritmus}{
    \floatname{algorithm}{Algoritmus}
    \begin{algorithm}
}{\end{algorithm}}

\newtheorem{tvrzeni}{Tvrzení}
\newtheorem{definice}{Definice}
\newtheorem{veta}{Věta}

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Hlavička
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\department{Katedra počítačových systémů}
\title{Asymetrický šifrovací algoritmus McEliece}
\authorGN{Vojtěch}
\authorFN{Myslivec}
\authorWithDegrees{Bc. Vojtěch Myslivec}
\supervisor{prof. Ing. Róbert Lórencz, CSc.}
%TODO
%\acknowledgements{Rodina, Lórencz, Kalvoda, Guth}
%TODO
\abstractCS{Tady bude nejaky kuuul abstakt } %TODO
%TODO
\abstractEN{Sem doplňte ekvivalent abstraktu Vaší práce v~angličtině.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{McEliece, asymetrická kryptografie, postkvantová kryptografie,
binární Goppa kódy, konečná tělesa, polynomy, Wolfram Mathematica}
\keywordsEN{McEliece, public-key cryptography, post-quantum cryptography, binary
Goppa codes, finite fields, polynomy, Wolfram Mathematica}




% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Dokument
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

% ====================================================================
% ====================================================================
% ====================================================================
\begin{introduction}
Tato práce se zabývá asymetrickým kryptosystémem \emph{McEliece}. Mezi největší
přednosti tohoto systému patří jeho odolnost vůči kvantovým počítačům a je tak
jedním z~vhodných kandidátů pro asymetrickou kryptografii pro postkvantovou
dobu.

%TODO
V~prvních kapitolách této práce jsou popsány nezbytné primitivy z~oblasti
matematiky a teorie kódování, které jsou potřeba pro pochopení a použití
kryptosystému McEliece. Jedná se především o~počítání s~\emph{konečnými tělesy}
a \emph{polynomy} (kapitola \ref{kap_telesa}) a binární \emph{Goppa} kódy
(kapitola \ref{kap_kody}).

Kryptosystému \emph{McEliece} se věnuje kapitola \ref{kap_mceliece}. Kromě
základního popisu generování klíčů a algoritmů pro šifrování a dešifrování je
probráno i kryptosystém \emph{Niederreiter} -- \uv{úprava} kryptosystému
\emph{McEliece} pro získání \emph{digitálního podpisu}. Jsou ukázány slabiny,
nevýhody i možné útoky na kryptosystém McEliece a též zmíněna praktická varianta
systému odolná vůči těmto aspektům.

V~poslední části  práce je probrána implementace kryptosystému \emph{McEliece}
v~softwaru \emph{Wolfram Mathematica} včetně změřených časových
% TODO a prostorových
složitostí (kapitola \ref{kap_implementace}),.

\end{introduction}

%\chapter{Cíl práce}

% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Obecná algebra}\label{kap_telesa}
V~kapitole jsou probrány definice a algoritmy nutné pro práci s~\emph{konečnými
tělesy} a \emph{polynomy} nad konečným tělesem. V~práci se předpokládá
základních znalostí z~oblasti \emph{algebry}. Pro tato témata je doporučena
literatura \cite{FIT_MPI,FIT_MKY,FIT_LIN,FIT_BHW,Paar} (kde lze též
najít většinu důkazů následujících vět).

\paragraph{Poznámka} \hfil \\
Algoritmy zmíněné v~následujících kapitolách jsou detailně
-- včetně pseudokódu -- popsány v~kapitole zabývající se implementací
(kapitola~\ref{kap_implementace}).
% ====================================================================
\section{Základní termíny}
Pro ujasnění je uvedena definice tělesa:

\begin{definice}[Těleso]
    Nechť $M$ je neprázdná množina a $+$ a $\cdot$ binární operace\footnote{
        Pro zjednodušení zápisu je $\cdot$ často vynecháváno.
    }. Struktura
    $T=\big(M, +, \cdot \big)$ se nazývá těleso, pokud platí
    \begin{enumerate}
        \item $\big(M, +\big)$ je \emph{komutativní grupa} (nazývána
            \emph{aditivní})
        \item $\big(M\setminus\{\mathit{0}\}, \cdot \big)$\footnote{
                Prvek $\mathit{0}$ je \emph{nulový} (\emph{neutrální}) prvek
                \emph{aditivní grupy}.
            } je \emph{grupa} (nazývána
            \emph{multiplikativní})
        \item Platí (levý i pravý) \emph{distributivní zákon}:
            $$\forall a,b,c \in M : \big( a(b+c) = a b + a c \big) \land \big(
            (b+c)a = b a + c a \big) $$
    \end{enumerate}
\end{definice}

{\setlength{\parindent}{0cm}
\emph{Těleso}, které má konečný počet prvků, se nazývá \emph{konečné těleso}.
}

\begin{veta}
    Nechť $T$ je \emph{konečné těleso}, pak jeho počet prvků (\emph{řád}) je
    $p^n$, kde $p$ je prvočíslo a $n \in \mathbb{N} \land n \geq 1 $.
\end{veta}
%\begin{proof} TODO
%\end{proof}

Číslo $p$ se nazývá \emph{charakteristika}. Navíc platí, že \emph{všechna
konečná tělesa} se stejným počtem prvků jsou navzájem \emph{izomorfní}.
\emph{Konečné těleso} řádu $p^n$ je tedy dále označováno jako $GF(p^n)$
(z~anglického \emph{Gallois field}, dle francouzského matematika
\emph{Évariste Galois}).

% ====================================================================
\section{Reprezentace prvků}
Jak bude ukázáno dále, je vhodné prvky tělesa $GF(p^n)$ reprezentovat jako
\emph{polynomy} s~koeficienty z~množiny $\mathbb{Z}_p=\{0,1,\ldots,p-1\}$, tedy
prvek $a \in GF(p^n)$ lze zapsat:
$$ A(x) = \sum_{i=0}^{n-1} a_i x^i, a_i \in \mathbb{Z}_p $$

O~takovém polynomu říkáme, že je to \emph{polynom nad tělesem $GF(p)$ (řádu
maximálně $n-1$)}. Na prvek $a$ je též možné se dívat jako na vektor či $n$-tici
koeficientů~$a_i$:
$$ A(x) \cong a \cong (a_{n-1} a_{n-2} \ldots a_0) \cong a_{n-1} a_{n-2}
\ldots a_0 $$

V~této práci se mezi těmito reprezentacemi prvků nadále volně přechází, jak
bude v~daném kontextu potřeba\footnote{
    V~některých materiálech se používá i obráceného zápisu
    $(a_0 a_1 \ldots a_{n-1})$.
}.

% ====================================================================
\section{Operace v~tělese $GF(p^n)$}
V~následujících sekcích jsou probrány operace potřebné pro počítání
s~tělesy $GF(p^n)$. Konkrétní zvolené algoritmy a jejich implementace
je detailně popsána v~kapitole \ref{kap_implementace}.

% --------------------------------------------------------------------
\subsection{Sčítání}
Sčítání v~tělese $GF(p^n)$ je definováno stejně jako sčítání polynomů, s~tím, že
sčítání jednotlivých koeficientů je prováděno \emph{modulo $p$} (v~tělese $GF(p)$:
$$ A(x) + B(x) = \sum a_i x^i + \sum b_i x^i = \sum \left|a_i + b_i\right|_p x^i $$


% --------------------------------------------------------------------
\subsection{Násobení}
Násobení v~tělese $GF(p^n)$ nelze provádět \uv{po složkách}, jako je tomu
u~sčítání. U~takto definované operace by většina prvků neměla (multiplikativní)
\emph{inverzi} a nejednalo by se tak o~\emph{těleso}.

Při násobení prvků se opět využije jejich reprezentace pomocí polynomů.
Výsledkem násobení pak je:
$$ A(x) \cdot B(x) = \sum_{i=0}^{n-1} a_i x^i \cdot \sum_{i=0}^{n-1} b_i x^i =
\sum_{i=0}^{2n-2} \left|\sum_{j+k=i} a_j \cdot b_k\right|_p x^i$$

Jak je naznačeno, násobení i sčítání koeficientů se provádí \emph{modulo} $p$
(v~tělese $GF(p)$.

Kvůli uzavřenosti násobení v~tělese je nutné zavést operaci zbytek po dělení
polynomu $A(x)$ polynomem $P(x)$, neboli $A(x) \mod P(x)$. Dále je třeba pro
určení tělesa $GF(p^n)$ určit \emph{ireducibilní} polynom, který bude použitý
při operaci násobení.

\begin{definice}
    Polynom $P(x)$ nad tělesem $GF(p)$ je \emph{ireducibilní} právě tehdy, když
    pro každé dva polynomy $A(x)$ a $B(x)$ nad $GF(p)$ platí:
    $$ A(x) \cdot B(x) = P(x) \Rightarrow \left( deg(A(x)) = 0 \right) \lor
    \left( deg(B(x)) = 0 \right)$$
\end{definice}

Neboli pro \emph{ireducibilní} polynom platí, že neexistuje rozklad na polynomy
nad $GF(p)$ stupně alespoň $1$.

\paragraph{Příklad} Polynom $x^3+x+1$ je nad tělesem $GF(2)$ \emph{ireducibilní},
protože neexistuje jeho rozklad na polynomy stupně alespoň $1$. \\
Polynom $x^2+1$ není nad tělesem $GF(2)$ \emph{ireducibilní}, protože:
$$(x+1)\cdot(x+1) = x^2 + \left|1+1\right|_2x + 1 = x^2+1 $$

Nyní je možné zavést operaci násobení dvou prvků tělesa jako násobení dvou
polynomů \emph{modulo} \emph{zadaný ireducibilní} polynom:
$$ A(x) \cdot B(x) = \sum a_i x^i \cdot \sum b_i x^i =
\sum \left|\sum_{j+k=i} a_j \cdot b_k\right|_p x^i \mod P(x) $$


\paragraph{Poznámka} \hfil \\
Pokud by zvolený $P(x)$ nebyl \emph{ireducibilní}, jednalo
by se o~\emph{okruh}, nikoliv o~\emph{těleso}, protože by neexistovala
\emph{multiplikativní inverze} pro některé prvky a navíc by i existovaly
tzv. \emph{dělitelé nuly}.


% --------------------------------------------------------------------
\subsection{Umocňování}
Pro rozšíření operací o~opakované násobení je vhodné zavést operaci umocňování.

\begin{definice}
    Pro prvek $a$ tělesa $T$ a číslo $n\in\mathbb{N}$ je operace
    umocňování definována následovně:
    \begin{align*}
        a^0     &= 1 \\
        a^n     &= \underbrace{a \cdot a \cdot \ldots \cdot a}_{\text{$n$-krát}}\\
        a^{-n}  &= \left(a^{-1}\right)^n
    \end{align*}
\end{definice}

Pro efektivní výpočet mocniny prvku je vhodné použít algoritmus
\emph{Square-and-Multiply}, kde se dílčí operace \uv{square} a \uv{multiply}
provádí operací $\cdot$ v~daném tělese $GF(p^n)$.

% --------------------------------------------------------------------
\subsection{Inverze}
\emph{Inverzi} v~\emph{grupě} lze obecně definovat následovně:
\begin{definice}[Inverze]
    Nechť $a$ je prvkem a $\mathbb{O}$ neutrálním prvkem \emph{grupy} \\
    $G = (M,\circ)$. Prvek $\bar{a}$ je \emph{inverzí} prvku $a$, pokud
    platí následující rovnice:
    $$ a \circ \bar{a} = \mathbb{O} $$
\end{definice}

\subsubsection{Aditivní inverze}
Inverze v~\emph{aditivní grupě} je značena znaménkem minus \uv{$-$} a je
z~definice velmi triviální:
$$ \left| A(x) + (-A(x)) \right|_p = 0 \Rightarrow
-A(x) = \sum \left|-a_i\right|_p x^i $$

Neboli je to aditivní inverze jednotlivých koeficientů \emph{modulo} $p$
(v~tělese $GF(p)$).


\subsubsection{Multiplikativní inverze}
Inverze v~\emph{multiplikativní grupě} je značena záporným exponentem
\uv{$^{-1}$} či symbolem dělení.
$$ \left| A(x) \cdot A(x)^{-1} \right|_p =
\left| \frac{A(x)}{A(x)} \right|_p = 1 $$

Tuto \emph{multiplikativní inverzi} je třeba počítat \emph{rozšířeným Euklidovým
algoritmem pro polynomy} (\emph{EEA}), či případně jinými algoritmy, jako je
např. \emph{algoritmus Itoh-Teechai-Tsujii} (\emph{ITT}) \cite{FIT_BHW,ITT}.

\emph{Rozšířený Euklidův algoritmus} \emph{pro polynomy}, stejně jako
v~modulární aritmetice (neboli pro tělesa $GF(p)$), stojí na nalezení
\emph{Bézoutovy rovnosti}. Pro výpočet \emph{EEA} je třeba výpočtu dělení
polynomů se zbytkem\footnote{
    Někdy uváděno jako dlouhé dělení.
}.

% ====================================================================
\section{Rozšířená tělesa}

% TODO
\emph{Prvotěleso}





% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Lineární kódy}\label{kap_kody}

% ====================================================================
\section{Kódování}

% ====================================================================
\section{Lineární kódy}
% --------------------------------------------------------------------
\subsection{Hammingovy kódy}

% ====================================================================
\section{Goppa kódy}
\emph{Ireducibilní binární Goppa kódy}

\emph{Pattersonův algoritmus}

\emph{Chien search} , \ldots

\emph{List Decoding}  \cite{Repka}




% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Kryptosystém McEliece}\label{kap_mceliece}
Kryptosystém \emph{McEliece} je asymetrický šifrovací algoritmus, publikovaný
poprvé v~roce \emph{1978} \emph{Robertem McEliece} \cite{McEliece}.
V~této kapitole jsou probrány algoritmy navržené \emph{Robertem
McEliece}, dále kryptosystém \emph{Niederreiter} a varianta pro získání
elektronického podpisu. Dále jsou zmíněny výsledky a závěry existujících
kryptoanalýz systému \emph{McEliece} a nakonec je věnováno aktuálním variantám
a~úpravám \emph{kryptosystému}.

\paragraph{Poznámka} \hfil \\
V~této kapitole je nadále předpokládáno počítání s~hodnotami z~tělesa $GF(2)$,
respektive s~\emph{bity}.

% ====================================================================
\section{Asymetrické šifrování McEliece}
Asymetrický kryptosystém \emph{McEliece} je založený na lineárních samoopravných
kódech. V~následujících odstavcích systém popsán tak, jak byl
definován v~\cite{McEliece}:

% --------------------------------------------------------------------
\subsection{Generování klíčů}
Generování klíčů probíhá následovně:

\begin{enumerate}
    \item Zvolí se \emph{lineární kód}\footnote{
            V~článku je kryptosystém definovaný pro libovolný \emph{lineární
            kód} opravující zvolený počet chyb a jsou zmíněny \emph{Goppa} kódy
            jako vhodný příklad k~použití. Jak bude ukázáno dále, ne všechny
            lineární kódy jsou pro \emph{McEliece} vhodné.
        } $(n,k)$, opravující $t$ chyb (a pro který je znám efektivní dekódovací
        algoritmus) s~odpovídající $k \times n$ \emph{generující maticí}~$G$.
    \item Vygeneruje se \emph{náhodná} $k \times k$ \emph{regulární} matice $S$.
    \item Vygeneruje se \emph{náhodná} $n \times n$ \emph{permutační} matice $P$.
    \item Vypočítá se $k \times n$ matice $\hat{G} = S G P$.
\end{enumerate}

Potom čísla $k$, $n$ a $t$ jsou \emph{veřejné parametry} systému, matice
$\hat{G}$ je \emph{veřejný klíč} a kód s~maticí $G$ a matice $S$ a $P$ jsou
\emph{soukromý klíč}.

\paragraph{Poznámka} \hfil \\
Při generování klíčů je třeba vygenerovat regulární matici $S$. Pravděpodobnost,
že náhodná čtvercová matice nad $GF(2)$ je regulární, je přibližně $33$\;\%.
Toto tvrzení nebylo dokázáno, nicméně numerické výpočty tomu
nasvědčují~\cite{Heyse}. Pro získání této matice je tak v průměru potřeba
vygenerovat $3$ náhodné matice, což znamená $3\times n^2$ bitů. Efektivněji je
možné matice generovat například dle~\cite{Randall}

% --------------------------------------------------------------------
\subsection{Algoritmy pro šifrování a dešifrování}\label{kap_mceliece_algoritmy}
\subsubsection{Šifrování}
Šifrování zprávy $m$ (o~délce $k$ bitů) veřejným klíčem $\hat{G}$ probíhá
následujícím způsobem:

\begin{enumerate}
    \item Vygeneruje se náhodný vektor $z$ délky $n$ s~\emph{Hammingovou vahou}
        maximálně $t$\footnote{
            V~některých pozdějších pracích na toto téma je
            uvedeno právě $t$.
        }.
    \item Šifrovaná zpráva $c$ délky $n$ se sestrojí následujícím způsobem:
        $$ c = m \hat{G} + z$$
\end{enumerate}

\subsubsection{Dešifrování}
Obdržená zašifrovaná zpráva $c$ (délky $n$) se dešifruje následujícím způsobem:

\begin{enumerate}
    \item Vypočítá se vektor $\hat{c}$ délky $n$: $\hat{c} = c P^{-1}$.
    \item Vektor $\hat{c}$ se dekóduje zvoleným kódem na vektor $\hat{m}$ \\
        $\hat{m} = Dek_{G}\left(\hat{c}\right)$
    \item Vypočítá se původní zpráva $m$: $m = \hat{m} S^{-1}$
\end{enumerate}

\subsubsection{Důkaz dešifrování}\label{kap_dukaz_desifrovani}
Důkaz, že výsledkem dešifrování je opět původní zpráva je následující:

\begin{itemize}
    \item V~prvním kroku dešifrovacího algoritmu je možné rozepsat původní
        zprávu~$m$:
        $$ \hat{c} = c P^{-1} = \left( m \hat{G} + z \right) P^{-1} =
        \left(m S G P + z \right) P^{-1} = \hat{c} = m S G + z P^{-1} $$
    \item Zavedeme substituci $\hat{m} = m S$ a $\hat{z} = z P^{-1}$, potom
        $$ \hat{c} = m S G + z P^{-1} = \hat{m} G + \hat{z} $$
        Z~poslední rovnosti je vidět, že dekódováním je získán vektor $\hat{m}$,
        neboť $\hat{z}$ je vektor s~\emph{Hammingovou vahou} maximálně $t$
        (matice $P$ jen přehází jednotlivé bity vektoru $z$).
        $$ Dek_{G}\left(\hat{c}\right) = \hat{m} $$
    \item V~posledním kroku stačí opět dosadit výše použitou substituci:
        $$ \hat{m} S^{-1} = m S S^{-1} = m $$
\end{itemize}

Dešifrováním je tedy získána původní zpráva $m$.

% --------------------------------------------------------------------
\subsection{Základní vlastnosti kryptosystému}
V~této kapitole jsou probrány základní fakta a vlastnosti \emph{kryptosystému}.
Jsou zde popsány způsoby uložení a velikost klíčů a hlavní výhody a nevýhody
použití \emph{McEliece}.

\subsubsection{Předpočítané matice}
Je vidět, že původní matice $S$ a $P$ se ve výpočtu nepoužívají a pro
dešifrování jsou potřeba pouze jejich \emph{inverze}. Je tedy možné tyto matice
předpočítat a \emph{soukromý klíč} je tak trojice kód s~generující maticí $G$,
matice $S^{-1}$ a matice~$P^{-1}$.

\subsubsection{Velikost klíčů}\label{kap_velikost_klicu}
Největší nevýhodou \emph{kryptosystému McEliece} je velikost klíčů. Již
v~původním článku jsou navrhovány parametry $n=1024$, $k=524$ a $t=50$\footnote{
    Jak bude zmíněno dále, velikost těchto parametry je pro dnešní použití
    nedostatečná.
}. Za použití těchto parametrů má matice $S$ (respektive její inverze)
$274576$\;b $\approx 268$\;kb a (inverze) matice $P$ $1048576$\;b $= 1$\;Mb.

Matice $P$ je ve skutečnosti velmi \emph{řídká} -- každý \emph{řádek}
(respektive i \emph{sloupec}) obsahuje pouze jednu jedničku, jinak je nulová. Je
to permutační matice a lze tak uchovat ve formě $\log_2 n$ $n$-bitových indexů.
Pro výše zmíněné hodnoty je to $10240$\;b $=10$\;kb.

% TODO odkaz na velikost kódu
% $3 m 2^m + (1-m)mt + m + 1 $
Při použití \emph{binárních Goppa kódů} s~těmito parametry je potřeba k~uložení
informace o~použitém kódu $\approx 26$\;kb. Celkem se jedná o~přibližně
$300$\;kb dat pro uložení soukromého klíče

Pro uložení \emph{veřejného klíče} (matice $\hat{G}$) je třeba $536576$\;b
$=524$\;kb dat.

Metody snížení velikosti klíčů \emph{kryptosystému McEliece} jsou jedním
z~hlavních překážek pro rozšíření algoritmu a také jedním z~hlavních cílů
zkoumání tohoto \emph{kryptosystému} a věnuje se jim
kapitola~\ref{kap_snizeni_velikosti_klicu}.

\subsubsection{Rychlost algoritmů}
Naopak jednou z~největších výhod algoritmu \emph{McEliece} je rychlost algoritmů
pro šifrování i dešifrování. Šifrování je prosté násobení matice s~vektorem, což
je jednoduchá operace, kterou je navíc možné provádět paralelně či efektivně
implementovat v~hardwaru. Dešifrování používá též násobení matic, ale složitější
operace je dekódování vektoru $\hat{m}$. Viz kapitola~\ref{kap_bezpecne_parametry}
a~tabulka~\ref{tab_Engelbert}.

% --------------------------------------------------------------------
\subsection{Bezpečnost kryptosystému}\label{kap_bezpecnost}
Již v~původním článku \cite{McEliece} \emph{McEliece} zmiňuje dva možné útoky na
navržený kryptosystém.
\begin{enumerate}
    \item získání \emph{soukromého} klíče ze znalosti \emph{veřejného}
    \item získání $m$ bez nutnosti znát \emph{soukromý} klíč
\end{enumerate}

Nicméně je dobré již na tomto místě zmínit, že existují útoky využívající
strukturu použitého kódu (tomuto tématu se věnuje
kapitola~\ref{kap_utoky_na_strukturu_kodu}).

\subsubsection{Získání soukromého klíče}
U~prvního způsobu je v~článku zmíněno, že je třeba rozložit $\hat{G}$ na $G$,
$S$ a $P$.  Matici $\hat{G}$ je sice možné dekomponovat, ale množství
jednotlivých matic je pro velká $n$ a $k$ obrovské, a získat tak původní matice
hrubou silou je \emph{neschůdné}\footnote{
    Např. jen počet možných \emph{permutačních matic} je $n!$. Počet
    \emph{generujících} matic závisí na zvoleném kódu.
    % TODO citace?  Počet regulárních matic nad $GF(2)$ je
    % $ \prod\limits_{i=0}^{k-1}(2^k - 2^i) $, což je přibližně jedna ze tří
    % $k \cdot k$ matic.
}.


\subsubsection{Získání původní zprávy}
Druhý způsob znamená dekódovat původní zprávu $m$ z~přijaté zprávy $c$,
která navíc obsahuje chybový vektor. Provést toto dekódování bez znalosti
použitého kódu je \emph{NP-těžký} problém \cite{Berlekamp}.

\paragraph{Naznačení problému} \hfil \\
V~případě, že by byl chybový vektor \emph{nulový}, platila by rovnost
$c = m\hat{G}$. Výběrem $k$ \emph{dimenzí} (množina dimenzí
$\mathcal{K} \subset \{1,2,\ldots,n\}$ mající $k$ prvků) vznikne
$\hat{G}_{\mathcal{K}}$~a~$c_{\mathcal{K}}$ z~matice~$\hat{G}$ respektive
vektoru~$c$. Pokud je $\hat{G}_{\mathcal{K}}$ regulární, lze řešit soustavu $k$
nerovnic pro $k$ neznámých ($m_i$) v~polynomiálním (!) čase $O\left(k^3\right)$:

$$c_{\mathcal{K}} = m \hat{G}_{\mathcal{K}}$$

Za použití šifrovacího algoritmu \emph{McEliece} je vektor $c$ \uv{zakrytý}
náhodným chybovým vektorem $z$ \emph{Hammingovy váhy} $t$. Potom
pravděpodobnost, že $c_{\mathcal{K}}$ (ve výběru $k$ dimenzí) je bez chyby je
$\left(1-\frac{t}{n}\right)^k$ \cite{McEliece}. Pro $O\left(k^3\right)$ operací
% TODO je ta pravděpodobnost správně?
pro vyřešení jedné soustavy rovnic je to přibližně:
$$ O\left( \frac{n^3}{\left(1-\frac{t}{n}\right)^k} \right) =
O\left( n^3 \left(\frac{n}{n-t}\right)^k \right)$$

Zlomek $\frac{n}{n-t}$ je jistě větší než $1$, tudíž pro velká $k$ výrazně
převyšuje druhý činitel a jedná se o~\emph{NP-těžký} problém.

Navíc není jasné, \emph{které} z~nalezených řešení odpovídá původní zprávě $m$.

% ====================================================================
\section{Kryptosystém Niederreiter}
V~roce 1986 publikoval \emph{Harald Niederreiter} v~\cite{Niederreiter}
kryptosystém s~veřejným klíčem využívající stejných principů jako kryptosystém
\emph{McEliece}. Tento kryptosystém je též založený na \emph{lineárních kódech}
a jeho bezpečnost též stojí na problému dekódování neznámého kódu. Na rozdíl
však od kryptosystému \emph{McEliece} používá k~sestrojení klíčů
\emph{kontrolní} matici místo matice \emph{generující}.

% --------------------------------------------------------------------
\subsection{Generování klíčů}
Generování klíčů probíhá následovně:
\begin{enumerate}
    \item Zvolí se \emph{lineární kód} $(n,k)$, opravující $t$ chyb
        s~odpovídající $(n-k) \times n$ \emph{kontrolní maticí}~$H$.
    \item Vygeneruje se \emph{náhodná} $(n-k) \times (n-k)$ \emph{regulární}
        matice $S$.
    \item Vygeneruje se \emph{náhodná} $n \times n$ \emph{permutační}
        matice~$P$.
    \item Vypočítá se $(n-k) \times n$ matice $\hat{H} = S H P$.
\end{enumerate}

Potom čísla $k$, $n$ a $t$ jsou \emph{veřejné parametry} systému, matice
$\hat{H}$ je \emph{veřejný klíč} a kód s~\emph{kontrolní} maticí $H$ a matice
$S$ a $P$ jsou \emph{soukromý klíč}.


% --------------------------------------------------------------------
\subsection{Algoritmy pro šifrování a dešifrování}
\subsubsection{Šifrování}
Šifrování zprávy probíhá následujícím způsobem:
\begin{enumerate}
    \item Zpráva $m$ dlouhá $n$ bitů s~\emph{Hammingovou vahou} maximálně $t$.
        Tato zpráva reprezentuje \emph{chybový vektor} pro použitý kód.
    \item Šifrový text $c$ (délky $n-k$) se spočte jako \emph{syndrom} zprávy
        $m$ (respektive chyby) za použití matice $\hat{H}$: $c = m \hat{H}^T$.
\end{enumerate}

\paragraph{Poznámka} \hfil \\
Chybový vektor $m$ požadované délky $n$ a \emph{Hammingovy váhy} $t$ lze
získat \emph{zakódováním}\footnote{
    Zde nejsou na mysli samoopravné kódy, ale pouze jednoznačné zakódování
    zprávy.
} původní zprávy k~zašifrování. Je vidět, že možných zpráv je pro $t \ll n$
řádově méně než všech možných vektorů délky $n$. Způsob zakódování bude probírán
níže při popisu získání \emph{elektronického podpisu} pomocí tohoto
\emph{kryptosystému}.



\subsubsection{Dešifrování}
Obdržená šifrová zpráva $c$ se dešifruje následujícím způsobem:
\begin{enumerate}
    \item Vypočte se vektor $\hat{c}$ délky $n-k$:
        $\hat{c} = c \left(S^T\right)^{-1} $
    \item Pomocí dekódovacího algoritmu použitého kódu se z~$\hat{c}$ získá
        chybový vektor $\hat{m}$ (délky $n$).
    \item Původní zpráva $m$ se získá výpočtem
        $m = \hat{m} \left(P^T\right)^{-1}$
\end{enumerate}


\paragraph{Poznámka} \hfil \\
Stejně jako je tomu u~\emph{kryptosystému McEliece}, je možné hodnoty
$\left(P^T\right)^{-1}$ a $\left(S^T\right)^{-1}$ předpočítat. Navíc inverzi
$P$ je opět možné uložit jako $\log_2 m$ $n$-bitových hodnot, jelikož se jedná
o~permutaci. Soukromý klíč je tak trojice kód s~kontrolní maticí $H$,
matice $\left(P^T\right)^{-1}$ a matice $\left(S^T\right)^{-1}$.


\subsubsection{Důkaz dešifrování}
Důkaz, že výsledkem dešifrování je opět původní zpráva je následující:

\begin{itemize}
    \item V~prvním kroku dešifrovacího algoritmu je možné výpočet rozepsat
        následujícím způsobem:
    $$ \hat{c} =   c \left(S^T\right)^{-1} =
                    m \hat{H}^T \left(S^T\right)^{-1} =
                    m P^T H^T S^T \left(S^T\right)^{-1} =
                    m P^T H^T
    $$
    \item Zavedeme substituci $\hat{m} = m P^T$, potom $\hat{c} = \hat{m} H^T$,
        což odpovídá výpočtu \emph{syndromu} pro použitý kód. Jelikož $\hat{m}$
        je pouze \emph{permutovaná} původní $m$, má \emph{Hammingovu váhu} $t$
        a pomocí dekódovacího algoritmu získáme $\hat{m}$ jako \emph{chybový
        vektor}.
    \item Nakonec se jen vynásobí inverzí matice $P^T$

\end{itemize}

% --------------------------------------------------------------------
\subsection{Vlastnosti kryptosystému}
Kryptosystém \emph{Niederreiter} je variantou asymetrického kryptosystému
založeného na lineárních kódech, podobně jako kryptosystém
\emph{McEliece}. Šifrovým textem není zakódované slovo, jak je tomu
u~\emph{McEliece}, nýbrž \emph{syndrom} chybového vektoru, který je možné
dekódovat pouze za znalosti skrytého lineárního kódu.

V~\cite{XingLi} byla dokázána ekvivalence složitosti prolomení tohoto
kryptosystému s~kryptosystémem \emph{McEliece}. Útočník, který dokáže prolomit
jeden ze systémů dokáže prolomit i druhý. Další informace jsou k~nalezení
v~\cite{Niederreiter,Courtois}.



% ====================================================================
\section{Elektronický podpis}
V~původním článku od \emph{Roberta McEliece} \cite{McEliece} bylo zmíněno, že tímto
navrženým kryptosystémem nelze získat schéma pro \emph{elektronický podpis}.
Původní algoritmy byly navržené pouze pro \emph{asymetrické šifrování}. Až
v~roce 2001 byl v~\cite{Courtois} publikován postup pro získání elektronického
podpisu za pomocí asymetrického kryptosystému založeného na samoopravných
kódech.

% --------------------------------------------------------------------
\subsection{Překážky pro použití McEliece pro podepisování}
Aby bylo možné využít algoritmus pro dešifrování jako algoritmus
\emph{podepisování}, bylo by potřeba, aby vektor $c$ (resp. $\hat{c}$) bylo
možné dekódovat na kódové slovo. Nicméně pro původně navrhované parametry je
poměr počtu vektorů délky $n$ v~\emph{Hammingově vzdálenosti} $t$
od kódových slov ku všem vektorům délky $n$ téměř nulový. Takový algoritmus pro
podepisování by prakticky vždy selhal a nebylo by možné získat žádný výstup jako
\emph{podpis}.

Konkrétně pro navrhované parametry $n=1024$, $t=50$ (a $k=524$) je počet
vektorů do \emph{Hammingovy vzdálenosti} $50$ od všech kódových slov:
$$ 2^{524}\sum_{i = 0}^{50}\binom{1024}{i} \approx 2^{808}$$
Počet všech vektorů délky $1024$ je $2^{1024}$. Tedy pravděpodobnost, že vektor
délky $1024$ půjde algoritmem \emph{dekódovat} je přibližně $2^{-216}$
\cite{McEliece}.

Algoritmus \emph{Niederreiter} selhává naprosto stejným stejným způsobem
\cite{Courtois}.

% --------------------------------------------------------------------
\subsection{Schéma pro elektronický podpis}\label{kap_schema_pro_podpis}
V~roce 2001 autoři \emph{Courtois} a spol. v~\cite{Courtois} publikovali postup,
jakým lze získat z~kryptosystému založeném na lineárních kódech schéma pro
\emph{elektronický podpis}. Autoři zmiňují, že je možné stejným způsobem využít
i kryptosystém \emph{McEliece}, nicméně kvůli délce výsledného \emph{podpisu} je
mnohem praktičtější využít kryptosystém \emph{Niederreiter}.

\subsubsection{Vyhovující parametry}
V~článku je dokázán vzorec pro pravděpodobnost, že náhodný \emph{syndrom} délky
$n-k$ (a při použití \emph{Goppa kódů}) je možné dekódovat je
$$
    \mathcal{P} = \frac{N_{\text{dekódovatelné}}}{N_{\text{celkem}}} \approx
    \frac{\frac{n^t}{t!}}{n^t} = \frac{1}{t!}
$$

%Vektorů vyhovující podmínce je
%$$\sum_{i=0}^{t}\left(\!
%\begin{array}{c}
%    n \\
%    i
%\end{array}
%\!\right) $$
%a v případě požadavku na \emph{Hammingovu váhu} právě $t$ je jich pouze
%$$\left(\!\begin{array}{c}
%    n \\
%    t
%\end{array}\!\right)$$ což je mnohem méně než všech možných vektorů $2^n$.

A~závisí tedy pouze na počtu chyb $t$. V~článku je popsána volba
parametrů\footnote{
    S~ohledem na útok \emph{Canteaut-Chabaud} \cite{Canteaut}.
} a pro bezpečnost odpovídající $80$ bitům symetrické šifry jsou zvoleny
parametry $n=2^{16}$ a $t=9$.  Pravděpodobnost, že pro zadané parametry bude
náhodný vektor možné dekódovat jako \emph{syndrom} je $\frac{1}{9!} \approx
2^{-19}$. Pro získání platného \emph{syndromu} bude tedy nutné v~průměru
vygenerovat $2^{19}$ \emph{vektorů}.

\subsubsection{Popis schématu}
Dle kapitoly výše je nutné získat několik ($9!$) vektorů k~odpovídajícímu
\emph{dokumentu}, který je třeba \emph{podepsat}. To je možné zajistit jednoduše
použitím \emph{hashovací} funkce $h$ s~tím, že je
společně s~dokumentem hashován i náhodný index $i$. Ten je možné postupně
zvyšovat, dokud výstup $h$ nebude možné \emph{dekódovat} a získat odpovídající
chybový vektor $z$. Jak bude ukázáno dále, hodnota $i$ bude třeba pro ověření
podpisu a podpis je tak dvojice $(z,i)$.

\paragraph{Značení} \hfil \\
Nechť $h$ je kryptograficky bezpečná \emph{hashovací} funkce, jejíž výstup je
dlouhý přesně $n-k$ bitů. Dále $D$ je dokument, který je třeba \emph{podepsat}
a $ s = h\left(D\right)$ \emph{hash} (\emph{otisk}) dokumentu. Zřetězení $s$ a
$i$ bude značeno jako $(s|i)$ a $s_i = h(s|i)$ je tedy \emph{otisk} dokumentu za
použití odpovídajícího \emph{indexu} $i$.
Nejmenší $i$ takové, že $s_i$ lze dekódovat, bude značeno $i_0$. Odpovídající
$s_{i_0}$ je tedy \emph{syndrom}, který bude použitý pro podpis $D$. Nakonec
chybový vektor $z$ odpovídá \emph{syndromu} $s_{i_0}$ a podpis $S$ je tedy
$S = ( z | i_0 )$

\paragraph{Délka podpisu} \hfil \\
Délka podpisu závisí na uložení dat $z$ a $i_0$. Vektor $z$ je chybový vektor
odpovídajícího samoopravného kódu. Jeho \emph{Hammingova váha} je tedy maximálně
$t$ a je tedy velmi řídký. Existuje pouze $\binom{n}{t}$ vektorů \emph{váhy} $t$ a
délky $n$ a je tedy možné tento řídký vektor komprimovat. V~\cite{Courtois} je
uvedeno, jak všechny možné vektory seřadit a vyjádřit tak konkrétní vektor pouze
jeho \emph{indexem} $I_z$. Takový \emph{index} je pak možno uložit
v~$\log_2{\binom{n}{t}}$ bitech.

Index $i_0$ bude zabírat v~průměru $\log_2{t!}$ bitů a nelze ho uložit žádným
kompaktnějším způsobem.

Pro konkrétní uvedený příklad ($n=2^{16}$, $t=9$) je pak průměrná velikost
podpisu $S = ( I_z | i_0 ): \log_2{\binom{2^{16}}{9}} + \log_2{9!} = 125.5 + 18.4 =
144$\;b.

% --------------------------------------------------------------------
\subsection{Algoritmus pro podepisování}
Podpis je sestrojen následujícím způsobem:

\begin{itemize}
    \item Sestrojíme \emph{hash} $s$ dokumentu $D$: $s = h(D)$.
    \item Nalezneme nejmenší $i$ ($i_0$) takové, že $s_i = h(s|i)$ lze dekódovat.
    \item Použijeme \emph{Niederreiterův} algoritmus pro dešifrování k~nalezení
        chybového vektoru $z$, že $z\hat{H}^T = s_{i_0}$
    \item Převedeme $z$ na index $I_z$.
    \item Použijeme $S=(I_Z|i_0)$ jako podpis dokumentu $D$.
\end{itemize}

\subsection{Algoritmus pro ověření}
Ověření probíhá následujícím způsobem:

\begin{itemize}
    \item Převedeme index $I_z$ zpět na vektor $z$.
    \item Spočítáme $s_1 = z\hat{H}^T$ pomocí veřejného klíče $\hat{H}$
    \item Spočítáme \emph{hash} $s_2 = h(h(d)|i_0)$
    \item Pokud se $s_1$ a $s_2$ shodují, podpis je platný.
\end{itemize}

\subsection{Poznámky}
Bezpečnost schématu pro elektronický podpis závisí na jednosměrné funkci
dekódování syndromu. Tuto operaci není možné provést bez znalosti
\emph{soukromého klíče} -- matic $H$, $S$ a $P$.

V~případě použití kryptosystému \emph{McEliece} pro získání podpisu, bychom ve
třetím kroku algoritmu pro podepisování místo \emph{syndromu} slovo délky $k$.
Při zvolených parametrech ($n=2^{16}$ a $t=9$) je $k$ rovno $2^m - m t = 2^{16}
- 16 \cdot 9 = 64$\;kb, což je velikost pro podpis prakticky nepřijatelná
(často by byl podpis delší než původní \emph{dokument}).

%TODO
\clearpage


% ====================================================================
\section{Kryptoanalýza systému McEliece}
Již v~původním článku \cite{McEliece} byly naznačeny 2 aspekty, díky kterým je
možné považovat kryptosystém McEliece \emph{bezpečný}:


\begin{enumerate}
    \item Problém nalezení kódového slova \emph{obecného lineárního kódu}
        s~minimální vzdáleností k~danému vektoru
        -- \emph{problém obecného dekódování} -- je \emph{NP-těžký}
        \cite{Berlekamp}
    \item Není znám žádný algoritmus, který by \emph{bez znalosti tajných parametrů}
        dokázal nalézt kódové slovo efektivněji, než \emph{za použití obecného kódu}.
\end{enumerate}


Druhý z~těchto aspektů neplatí za použití libovolného kódu, jak bude ukázáno
v~kapitole \ref{kap_utoky_na_strukturu_kodu}. Při použití některých lineárních
kódů je možné odhalit strukturu použitého kódu.

I~přes tato tvrzení je nutné zvolit parametry $n$, $k$ a $t$ tak, aby útok
hrubou silou byl časově (a případně i prostorově) neschůdný. Volba bezpečných
parametrů je probrána v~kapitole \ref{kap_bezpecne_parametry}.


% --------------------------------------------------------------------
\subsection{Útoky na McEliece}
V~této kapitole jsou uvedeny některé z~útoků na kryptosystém \emph{McEliece}.
Dle~\cite{Engelbert} se útoky dají rozdělit do dvou hlavních kategorií:
\begin{itemize}
    \item útoky na soukromý klíč
    \item útoky na šifrový text
\end{itemize}
Do první kategorie spadají útoky na strukturu použitého kódu a \emph{Support
Splitting Algorithm}~\cite{Sendrier}. Jedná se o~útoky, ve kterých útočník ze znalosti
\emph{veřejného klíče} sestrojí klíč \emph{soukromý}. Do druhé kategorie spadají
útoky, které nezjišťují \emph{soukromý klíč}, ale z~\emph{šifrového textu}
odhalují text \emph{otevřený}. To zahrnuje \emph{útok s~informační množinou},
navržený již Robertem McEliece, \emph{nalezení kódového slova s~nízkou vahou}
a~další útoky na kryptosystém \emph{McEliece}.

Nerozumné použití kryptosystému vede na zneužití několika \emph{slabin}, které
jsou probrány ve zvláštní kapitole~\ref{kap_slabiny}\footnote{
    Nejedná se totiž o~útoky na kryptosystém ale spíše o~nepříjemné
    \emph{vlastnosti} kryptosystému, se kterými je nutné počítat.
}.

\subsubsection{Útoky na strukturu použitého kódu}\label{kap_utoky_na_strukturu_kodu}
V~historii byly zaznamenány pokusy o~sestrojení \emph{soukromého klíče} za
použití jiných lineárních kódů než \emph{Goppa kódů}. Tyto návrhy vznikají
hlavně kvůli zredukování velikosti klíčů, které jsou za použití \emph{Goppa
kódů} obrovské. Většina z~těchto návrhů ale byla shledána jako nedostatečně
bezpečná pro použití v~asymetrické kryptografii.

V~původním článku, kde byl definován kryptosystém \emph{Niederreiter}, bylo
navrženo použití \emph{zobecněných Reed-Solomon} (\emph{GRS})
kódů~\cite{Niederreiter}. V~\cite{Sidelnikov} bylo prokázáno, že je možné
skrytou strukturu \emph{GRS} kódu odhalit v~polynomiálním čase. Stejné podmínky
platí i pro použití v~kryptosystému \emph{McEliece}.

Použití tzv. \emph{Alternantních} či dalších kódů, používajících kompaktní
uložení klíčů bylo prolomeno \emph{algebraickou} a \emph{strukturální
kryptoanalýzou}~\cite{Faugere1,Faugere2,Umana}.


\subsubsection{Support Splitting Algorithm}
Tento algoritmus, navržený Nicolasem Sendrier, dokáže v~\emph{polynomiálním
čase} (přibližně $O(n^4)$) určit, zda 2 lineární kódy jsou
\emph{permutačně ekvivalentní}~\cite{Sendrier}.

\begin{definice}
    Nechť existují dva lineární kódy $\mathcal{K}_1$ a $\mathcal{K}_2$. Říkáme,
    že tyto kódy jsou \emph{permutačně ekvivalentní}, pokud všechna kódová slova
    kódu $\mathcal{K}_1$ lze převést na kódová slova $\mathcal{K}_2$ použitím
    stejné permutace bitů (pozic) $P$.
\end{definice}

Pokud má útočník k~dispozici \emph{Goppa kód} (určený polynomem $g$), dokáže
v~polynomiálním čase rozhodnout, jestli je permutačně ekvivalentní s~kódem, který
generuje \emph{veřejný klíč} $\hat{G}$. Pokud by bylo množství možných
\emph{Goppa polynomů} -- resp. \emph{Goppa kódů} -- nízké, útočník by mohl
hrubou silou odhalit použitý \emph{Goppa kód}. Z~tohoto důvodu je nutné, aby
generované \emph{Goppa polynomy} měly koeficienty z~větších binárních těles. Čím
větší budou vnitřní tělesa, tím více existuje možných (ireducibilních) polynomů
a není tak možné projít všechny možnosti hrubou silou~\cite{Repka}.

\subsubsection{Útok s~informační množinou}
\emph{Útok s~informační množinou} (\emph{Information Set Decoding attack} --
\emph{ISD}), který byl popsán již v~původním článku \emph{Roberta
McEliece}~\cite{McEliece} a~zmíněn v~kapitole~\ref{kap_bezpecnost}. Tento útok
byl formalizován a~zobecněn v~\cite{Lee}.

Útok je založen na výběru $k$ sloupců (dimenzí) (množina $K$) z~veřejně známé
matice $\hat{G}$ tak, aby vzniklá matice $\hat{G}_{\mathcal{K}}$ byla
\emph{regulární} a bylo možné vyřešit vzniklou soustavu rovnic

$$ c_{\mathcal{K}} = m \hat{G}_{\mathcal{K}} $$

Tomuto útoku brání fakt, že útočník neví, které bity šifrového textu jsou
(v~průběhu šifrování) \uv{zamaskované} vygenerovaným náhodným vektorem $z$.
Případný útočník tak zároveň musí vybrat dimenze takové, které nejsou zatížené
tímto chybovým vektorem.

Autoři \emph{Lee} a~\emph{Brickell} zobecnili tento útok tak, že není nutné
vybrat množinu dimenzí, která neobsahuje chybu. Pokud bude množství chyb malé,
je možné tento fakt do algoritmu započítat a bity vektoru $c$ respektive
$c_{\mathcal{K}}$ invertovat.

Pravděpodobnost, že výběr $k$ dimenzí bude obsahovat maximálně $j$ chyb je

$$
    \mathcal{P}_j= \frac{N_{\text{max. $j$ chyb}}}{N_{\text{celkem}}}
    = \frac{\sum_{i=0}^{j}\binom{t}{i}\binom{n-t}{k-i}}{\binom{n}{k}}
$$

A~počet všech vektorů $e_\mathcal{K}$, jejichž \emph{Hammingova váha} je menší
než $j$ (tedy počet vektorů, které je třeba vyzkoušet a zprávu $c$ dle tohoto
vektoru invertovat) je

$$ N_j = \sum_{i=0}^{j}\binom{k}{i} $$

Pokud je možné řešit soustavu $k$ lineárních rovnic v~$O(k^3)$ počtu krocích, je
asymptotická složitost tohoto útoku

$$ W_j = O\left( \mathcal{P}_{j}^{-1}\left(k^3 + k N_j \right) \right) $$

V~průměru je totiž provést $\mathcal{P}_{j}^{-1}$ výběrů dimenzí, pro každý
výběr provést v~průměru $k N_k$ invertování bitů a nakonec vyřešit soustavu
rovnic -- pokud je řešitelná.

Autoři uvádí, že pro minimalizaci $W_j$ je při rozumných velikostech kódů volit
$j=2$. Tento útok v~době publikování snížil složitost útoku na
\emph{kryptosystém McEliece} přibližně $2^11$-krát~\cite{Lee}.

\subsubsection{Nalezení kódového slova s~nízkou vahou}
Jako nejúspěšnější útok na nalezení tajné zprávy se v~posledních letech jeví
tzv. \emph{útok nalezením slova s~nízkou vahou}. Z~definice šifrování je známo,
že $c$ leží ve \emph{vzdálenosti} $t$ od \emph{nějakého} kódového slova.
Sestrojíme nový kód $\mathcal{K}'$ s~generující maticí $\hat{G}'$ tak, že
k~matici $\hat{G}$ přidáme šifrový text $c$ jako další řádek matice

$$
    \hat{G}' = \left(\begin{array}{c}
        \hat{G} \\
        c
    \end{array}\right) = \left(\begin{array}{c}
        \hat{G} \\
        m\hat{G} + z
    \end{array}\right)
$$

Původní kód generovaný maticí $\hat{G}$ měl \emph{kódovou vzdálenost} minimálně
$2t+1$ a nově vzniklý kód $\mathcal{K}'$ má \emph{kódovou vzdálenost} $t$. Navíc
jediný vektor, s~vahou $t$ je neznámý chybový vektor $z$ (který je potřeba
k~úspěšnému dekódování či útoku \emph{ISD}).

Cílem tohoto útoku je tedy nalézt kódové slovo $z$ (s~nejnižší vahou) z~výše
definovaného kódu $\mathcal{K}'$. Algoritmy představené
v~\cite{Leon,Stern,Canteaut} nejdříve hledají kódová slova v~redukovaném kódu
$\mathcal{K}'_S$, který vznikne výběrem náhodnou množinou dimenzí $S$ z~matice
$\hat{G}'$. Poté se tato kódová slova rozšíří do původního kódu $\mathcal{K}'$ a
zkontrolují, zda mají požadovanou \emph{váhu}.

Algoritmy představené autory \emph{Leon}~\cite{Leon}, \emph{Stern}~\cite{Stern}
a~\emph{Canteaut} a~\emph{Chabaud}~\cite{Canteaut} se liší hlavně ve způsobu
výběru dimenzí $S$. Poslední z~představených algoritmů dosahuje nejlepších
výsledků.


\subsubsection{Další útoky}
Existují též návrhy dalších útoků jako jsou například statistické
útoky~\cite{Jabri} či útok založený na \emph{bodových mřížích}~\cite{Brickell}.
Jako další zdroje pro zkoumání těchto útoků jsou doporučeny
články~\cite{Repka,Engelbert}.



% --------------------------------------------------------------------
\subsection{Bezpečné parametry}\label{kap_bezpecne_parametry}
Pro dosažení určité míry bezpečnosti se používá pojem \emph{počet bitů
bezpečnosti} (či \emph{míra bezpečnosti}). Tato jednotka odpovídá počtu bitů
klíče symetrické šifry, které by útočník musel hrubou silou prolomit. Jinými
slovy, pokud nějaká šifra (s~danou velikostí klíče) odpovídá $n$ bitům
bezpečnosti, je třeba vynaložit $O\left(2^n\right)$ operací.

Obecně je považováno \emph{128 bitů bezpečnosti} za dostatečné pro
\emph{střednědobé} účely a \emph{256 bitů} pro \emph{dlouhodobé}. Méně než \emph{80
bitů} je pro bezpečné uchování informací prakticky nepoužitelné, jelikož takto
\uv{silný} algoritmus lze (či půjde) prolomit v~dostatečně krátkém čase (méně
než desítky let)~\cite{Paar}.

Kryptosystém \emph{McEliece} má na rozdíl např. od \emph{RSA} několik parametrů
-- $n$, $k$, $t$ -- a celkové množství variant je tedy velmi mnoho.  Odhady
složitostí jednotlivých útoků se navíc celkem liší, a proto je v~této kapitole
uvedeno několik tabulek z~různých zdrojů, které odhadují \emph{míru bezpečnosti}
kryptosystému \emph{McEliece}.

V~tabulce \ref{tab_Bernstein} shrnuje parametry kryptosystému \emph{McEliece} pro
dosažení požadované míry bezpečnosti dle \cite{Bernstein} a tabulka
\ref{tab_Repka} dle \cite{Repka}. Tyto tabulky obsahují informaci o~velikosti
\emph{veřejného klíče} v~\emph{systematické formě}. Tabulka \ref{tab_Engelbert}
inspirovaná z~\cite{Engelbert,Paar} porovnává asymptotické
složitosti šifrování a dešifrování kryptosystému \emph{McEliece} a \emph{RSA}.

\emph{Míra bezpečnosti} původního navrženého kryptosystému
$\left(1024,524,50\right)$ se dle~\cite{Canteaut,Repka} pohybuje mezi
$50$-$60$ \emph{bity bezpečnosti} a tyto parametry jsou tedy pro praktické
použití nedostatečné.


% --------------------------------------------------------------------
\subsection{Slabiny kryptosystému}\label{kap_slabiny}
V~této kapitole jsou shrnuty známé slabiny kryptosystému \emph{McEliece}, se
kterými je nutné počítat a praktické použití šifrování pomocí \emph{McEliece}
náležitě upravit. Většina z~těchto slabin umožňuje útok pomocí (adaptivně)
voleného šifrového textu -- tzv. \emph{CCA2} útok,

Těmto slabinám se dá vyhnout díky použití \emph{CCA2} bezpečné konverzi
šifrového textu, která je popsaná v~kapitole \ref{kap_cca2}.


% TODO pozice tabulek
\begin{table}[t]
    \begin{center}
    \begin{tabular}{r|l|r}
        \multirow{2}{*}{\shortstack{Míra \\ bezpečnosti}} & \multirow{2}{*}{\shortstack{Parametry $\left(n,k,t\right)$}} & \multirow{2}{*}{\shortstack{Velikost \\ klíče}} \\
             & & \\
            \hline
         $80$\;b    & $\left(1632,1269,33\right)$   &  $450$\;kb    \\
        $128$\;b    & $\left(2960,2288,56\right)$   & $1502$\;kb    \\
        $256$\;b    & $\left(6624,5129,115\right)$  & $7488$\;kb    \\
    \end{tabular}
    \caption{Míra bezpečnosti \emph{McEliece} dle \cite{Bernstein}}
    \label{tab_Bernstein}
    \end{center}
\end{table}

\begin{table}
    \begin{center}
    \begin{tabular}{r|l|r}
        \multirow{2}{*}{\shortstack{Míra \\ bezpečnosti}} & \multirow{2}{*}{\shortstack{Parametry $\left(n,k,t\right)$}} & \multirow{2}{*}{\shortstack{Velikost \\ klíče}} \\
             & & \\
            \hline
         $50$\;b    & $\left(1024,524,50\right)$    &  $256$\;kb    \\
         $80$\;b    & $\left(2048,1696,32\right)$   &  $583$\;kb    \\
        $128$\;b    & $\left(3178,2384,68\right)$   & $1849$\;kb    \\
        $128$\;b    & $\left(4096,3604,41\right)$   & $1732$\;kb    \\
        $256$\;b    & $\left(6944,5208,136\right)$  & $8829$\;kb    \\
    \end{tabular}
    \caption{Míra bezpečnosti \emph{McEliece} dle \cite{Repka}}
    \label{tab_Repka}
    \end{center}
\end{table}

\begin{table}
    \begin{center}
    \begin{tabular}{l|l|r|r|r|l}
        \multirow{2}{*}{Kryptosystém} & \multirow{2}{*}{Parametry} & \multirow{2}{*}{\shortstack{Míra \\ bezpečnosti}} & \multirow{2}{*}{\shortstack{Velikost \\ klíče}} & \multicolumn{2}{c}{\shortstack{Složitost}} \\
        & & & & šifr. & dešifr. \\
            \hline
        \multirow{3}{*}{\emph{RSA}}
            & $1024$ modulus                & $\sim  80$\;b &    $1$\;kb & $2^{30}$ & $2^{30}$  \\
            & $2048$ modulus                & $\sim 112$\;b &    $2$\;kb & $2^{33}$ & $2^{33}$  \\
            & $4096$ modulus                & $\sim 145$\;b &    $4$\;kb & $2^{36}$ & $2^{36}$  \\
            \hline
        \multirow{3}{*}{\emph{McEliece}}
            & $ \left(2048,1608,40\right)$  & $\sim  98$\;b &  $691$\;kb & $2^{20}$ & $2^{23}$  \\
            & $ \left(2048,1278,70\right)$  & $\sim 110$\;b &  $961$\;kb & $2^{20}$ & $2^{24}$  \\
            & $ \left(4096,2056,170\right)$ & $\sim 184$\;b & $4096$\;kb & $2^{22}$ & $2^{26}$  \\
    \end{tabular}
    \caption{Porovnání \emph{McEliece} a \emph{RSA} dle \cite{Engelbert,Paar}}
    \label{tab_Engelbert}
    \end{center}
\end{table}


\subsubsection{Malleability}
Použití šifrování tak, jak je definováno v~kapitole \ref{kap_mceliece_algoritmy}
umožňuje deterministickým způsobem změnit (neznámou) zašifrovanou zprávu -- tzv.
\emph{mealleability}.

Zašifrovaná zpráva $c_1$ veřejným klíčem $\hat{G}$ byla zkonstruována (dle
definice) $c_1 = m_1\hat{G} + z$, kde $z$ je náhodný chybový vektor. Pokud
je tato zpráva $c_1$ zachycena, je možné ji pozměnit následujícím způsobem:

\begin{itemize}
    \item Připraví se (otevřená) zpráva $m_1$
    \item Tato zpráva se \uv{zašifruje} veřejným klíčem $\hat{G}$, ale nepoužije
        se chybový vektor $z$: $c_2 = m_2\hat{G}$
    \item K~původní zašifrované zprávě $c_1$ se přičte nová zpráva $c_2$:
        $c = c_1 + c_2$
    \item Odešle se vzniklá zpráva $c$ původnímu účastníkovi.
\end{itemize}

Dešifrování proběhne naprosto bezchybným způsobem, ale účastník získá
místo původní zprávy $m_1$ podvrženou zprávu $m_1+m_2$.

\begin{align*}
    D_G\left(c\right) &= D_G\left( c_1 + c_2 \right) = \\
                      &= D_G\left( (m_1\hat{G} + z) + m_2\hat{G} \right) = \\
                      &= D_G\left( (m_1+m_2)\hat{G} + z~\right) =\\
                      &= (m_1+m_2)
\end{align*}

Podobnou slabinu mají i algoritmy \emph{RSA} či \emph{ElGamal} \cite{FIT_KRY}. Stejně jako
u~těchto algoritmů (např. \emph{OAEP} pro \emph{RSA}) i pro \emph{McEliece} se
dá tomuto útoku efektivně bránit předem daným formátem zprávy a
\emph{paddingem}.

\subsubsection{Opakované šifrování stejné zprávy}
Pokud je jedna otevřená zpráva dvakrát zašifrovaná stejným klíčem, je možné ji
s~velkou pravděpodobností odhalit~\cite{Berson}. Pro každé šifrování je
generován náhodný (a pravděpodobně tedy jiný) chybový vektor $z$. Sečtením dvou
různých šifrových textů jedné zprávy se tak získá součet náhodných chybových
vektorů:

$$ c_1 + c_2 = (m\hat{G} + z_1) + (m\hat{G} + z_2) = z_1 + z_2 $$

\emph{Váha} každého z~vektorů je $t$ a délka $n$. Sečtením dvou šifrových textů
tak získáme vektor váhy maximálně $2t$. Tento výsledný vektor pak obsahuje
binární $1$ na pozicích, kde se vyskytují $1$ právě v~jednom z~chybových
vektorů. Jelikož jsou chybové vektory velmi řídké, je velmi pravděpodobné, že
výsledný vektor bude mít váhu právě $2t$. Pokud by vektory $z_1$ a $z_2$
obsahovaly $1$ na stejných pozicích, váha výsledného vektoru by byla o~$2$ menší
za každou takovou shodu. Počet možností chybového vektoru $z_1$ je pak řádově
nižší -- $\binom{2t}{t}$ místo původních $\binom{n}{t}$\footnote{
    Por praktické parametry kryptosystému platí $n \gg t$.
} -- a útok s~\emph{informační množinou} je tak řádově jednodušší.

Dle stejného principu stačí znát \emph{rozdíl} mezi dvěma zprávami. Označme
tento rozdíl jako $\Delta m = m_1 + m_2$. Sečtením dvou odpovídajících šifrových
textů získáme:

$$ c_1 + c_2 = (m_1\hat{G} + z_1) + (m_2\hat{G} + z_2) = \Delta m \hat{G} + z_1 + z_2 $$

Ze znalosti $\Delta m$ a veřejného klíče je možné opět získat součet chybových
vektorů $z_1 + z_2 $ a provést stejný útok na obě zprávy $m_1$ a $m_2$, jak bylo
uvedeno výše.


\subsubsection{Znalost části otevřeného textu}
Složitost útoku na šifrovanou zprávu lze též velmi zjednodušit, pokud útočník
bude znát alespoň část otevřeného textu. Nechť množina $\mathcal{I} \subset
\{1,2,\ldots,k\}$ reprezentuje pozici bitů, které útočník zná. Potom
$\mathcal{J}$ je doplněk této množiny~$\mathcal{I}$ a zašifrovanou zprávu $c$
lze rozdělit (dle dimenzí):

\begin{align*}
    c &= m\hat{G} + z~=
    m_{\mathcal{I}}\hat{G}_{\mathcal{I}} + m_{\mathcal{J}}\hat{G}_{\mathcal{J}} + z~\\
    \text{a tedy:} \qquad \qquad \\
    c + m_{\mathcal{I}}\hat{G} &= m_{\mathcal{J}}\hat{G}_{\mathcal{J}} + z~\\
                       \bar{c} &= m_{\mathcal{J}}\hat{G}_{\mathcal{J}} + z~\\
    \text{respektive:} \qquad \qquad \\
                       \bar{c} &= m_{\mathcal{J}}\hat{G}_{\mathcal{J}} + z_{\mathcal{J}}
\end{align*}


Stačí tedy útočit na dimenze určené množinou $\mathcal{J}$ a velikost
\emph{informační množiny} je tak zkrácena z~$k$ na velikost množiny
$\mathcal{J}$.


\subsubsection{Hádání chybových bitů}
Tento útok je též označován jako tzv. \uv{reakční útok}. Pro provedení tohoto
útoku je třeba mít k~dispozici \emph{dešifrovací orákulum} a útočník musí být
schopen rozlišit kdy došlo k~chybě v~dešifrování a kdy byla zpráva v~pořádku
dešifrována\footnote{
    Podobně jako např. útok \emph{Paddding Oracle} u~blokových šifer
    \cite{FIT_KRY}.
}.

Útočník, který zachytí zašifrovanou zprávu $c$, k~ni přičte vektor
s~\emph{Hammingovou vahou} 1: $\left(0\ldots010\ldots0\right)$. Takto upravenou
zprávu odešle \emph{orákulu} a pozoruje, jestli došlo k~úspěšnému dešifrování či
nikoliv. Pokud dešifrování selhalo, je jasné, že odeslaná upravená zpráva
obsahovala $t+1$ chyb a nebylo možné přijatou zprávu dekódovat. Pokud
dešifrování proběhne v~pořádku, upravená zpráva obsahovala $\leq t$ chyb, což
znamená, že vektor, kterým byla zpráva upravena, odpovídá jednomu z~náhodných
bitů chybového vektoru $z$.

Útočník tímto způsobem může bit po bitu vyzkoušet úspěšnost dešifrování upravené
zprávy a zrekonstruovat chybový vektor $z$ v~$O\left( n \right)$ krocích. Za
znalosti chybového vektoru je pak odhalení tajné zprávy $m$ otázka vyřešení
soustavy $k$ rovnic v~$O\left( k^3 \right)$ krocích.

Jako účinné zabránění tohoto útoku se nabízí vyžadovat, aby zašifrovaná zpráva
obsahovala \emph{právě} $t$ chyb. Při šifrování se to dá velmi snadno zařídit a
při dešifrování pak stačí zkontrolovat \emph{váhu} chybového vektoru (který je
získán při dekódování) a pokud není rovna $t$, je jasné, že nastalo k~manipulaci
se šifrovým textem.


% TODO zarovnání
\vfill


% ====================================================================
\section{Moderní varianty a úpravy}
Použití kryptosystému \emph{McEliece} tak, jak byl popsán na začátku kapitoly
\ref{kap_mceliece} by bylo pro účely šifrování velmi nerozumné a nepraktické. To
hlavně z~důvodu slabin, kterými algoritmus trpí (kapitola \ref{kap_slabiny})
a velikosti klíčů, které jsou v~základní variantě větší než je nezbytně nutné.
V~následujících kapitolách je probráno několik úprav \emph{kryptosystému} pro
praktické použití.

% --------------------------------------------------------------------
\subsection{Metody na snížení velikosti klíčů}\label{kap_snizeni_velikosti_klicu}
Jednou z~hlavních nevýhod kryptosystému \emph{McEliece} jsou obrovské klíče,
které reprezentují lineární kódy velkých rozměrů (\emph{Goppa kódy}) a matice
odpovídající velikosti, které mají za úkol schovat strukturu použitého kódu.
Metody na snížení velikosti klíčů se zaměřují hlavně na použití kódů, které je
možné definovat kompaktním způsobem a způsob uložení či generování
matic~$S$~a~$P$.

Zatím byly všechny pokusy vyměnit původní \emph{Goppa kódy} jinými,
kompaktnějšími lineárními kódy, neúspěšné. Nalezly se slabiny ve struktuře kódu,
které lze využít pro jejich sestrojení bez znalosti tajných matic $S$ a $P$ (viz
kapitola~\ref{kap_utoky_na_strukturu_kodu}. Jediné alternativní kódy, jejichž
použití zatím nebylo prolomeno, jsou \emph{kvazi-dyadické Goppa kódy}, které
jsou zmíněny v~kapitole~\ref{kap_kvazi}.

Kromě definovaného kódu jsou v~\emph{soukromém klíči} obsažené též dvě velké
matice $S$ a $P$. Snížením velikosti těchto matic se zabývá následující
kapitola.

Veřejný klíč je pouze jedna matice -- \uv{zamaskovaná} generující $n \times k$ matice
$\hat{G}$. Jako jediný způsob pro snížení počtu bitů tohoto veřejného klíče je
uložení matice v~\emph{systematické formě}. V~takovém případě není třeba
udávat prvních $k$ sloupců -- je jasné, že odpovídají \emph{jednotkové matici}
$I_k$. Při použití matice $\hat{G}$ v~\emph{systematické formě} se tedy ušetří
$k^2$ bitů, což při rozumných parametrech odpovídá až $75 $\;\% velikosti matice
$\hat{G}$. Aby byla zachována bezpečnost kryptosystému při použití takové
matice, je nutné použít \emph{CCA2-odolnou} konverzi (viz kapitola~\ref{kap_cca2}).

\subsubsection{Význam matic $S$ a $P$}
Jak již bylo řečeno v kapitole \ref{kap_velikost_klicu}, \emph{permutační}
matici $P$ není nutné ukládat jako matici bitů, ale pouze jako \emph{indexy}
permutace a velikost klíče tak komprimovat. Matice $S$ je náhodná regulární
matice a z definice nejde nijak komprimovat. Při hardwarové implementaci
v~\cite{Paustjan} bylo ale efektivně využito \emph{CSPRNG} jako
\emph{generátoru} této matice. Jednoznačnost matice $S$ je zde vyjádřena pomocí
tajného \emph{seedu} pro \emph{CSPRNG}.

Ač byl \emph{kryptosystém} navržený s maticemi $S$ a $P$ pro \emph{ukrytí}
\emph{generující} matice $G$, tak v~\cite{Engelbert} bylo ukázáno, že matice $S$
nemá žádnou bezpečnostní účel pro skrytí matice $G$. Naopak matice $P$ je velmi
důležitá a prozrazení této permutace by znamenalo prozrazení \emph{soukromého
klíče}.
Existují implementace \emph{kryptosystému}, které matici $S$ ve výpočtech vůbec
nezahrnují.
%todo


\subsubsection{Kvazi-dyadické Goppa kódy}\label{kap_kvazi}
Jako jedna z~úspěšných metod na zkrácení klíčů se v~posledních letech jeví
použití \emph{kvazi-dyadických Goppa kódů}~\cite{Misoczki1}.

\begin{definice}{Dyadická matice}
    \begin{itemize}
        \item Každá $1\times1$ matice je \emph{dyadická}. \\
        \item Nechť $A$ a $B$ jsou $2^{k-1}\times2^{k-1}$ \emph{dyadické} matice, pak
            $2^k\times2^k$ matice
            $$H = \left(\begin{array}{c c}
                A & B\\
                B & A
            \end{array}\right)$$
            je také \emph{dyadická}.
    \end{itemize}
\end{definice}


\begin{definice}{Kvazi-dyadická matice}
    Matice, která není \emph{dyadická}, ale skládá se z~\emph{dyadických}
    submatic je \emph{kvazi-dyadická}.
\end{definice}

Dyadická matice $H$ lze jednoznačně vyjádřit pomocí jediného (prvního) řádku
matice. Z~definice lze zkonstruovat celou původní matici $H$. Kvazi-dyadická
matice lze tak vyjádřit pomocí prvních řádků \emph{dyadických} submatic.


V~\cite{Misoczki1} autoři ukázali, že je možné sestrojit (binární) \emph{Goppa
kód}, který má kontrolní matici v~\emph{dyadické} formě -- tzv. \emph{dyadický
Goppa kód}. Takto sestrojený kód by ale bylo velmi snadné zrekonstruovat
z~veřejného klíče a navrhli tak použití \emph{kvazi-dyadického Goppa kódu} --
s~kontrolní maticí v~\emph{kvazi-dyadické} formě.

S~použitím \emph{kvazi-dyadických Goppa kódů} je dosaženo $n$ krát menších klíčů
než za použití obecných (binárních) \emph{Goppa kódů}~\cite{Misoczki1}.
Implementace \emph{kryptosystému} s~\emph{kvazi-dyadickými Goppa} kódy lze
nalézt např v~\cite{Paustjan,Kratochvil}

\subsubsection{MDPC McEliece}
Asi nejnovější varianta kryptosystému \emph{McEliece} je použití \emph{Moderate
Density Parity-Check} (\emph{MDPC}) kódů a kvazi-cyklických \emph{MDPC} kódů.
Autoři v~\cite{Misoczki2} navrhli použití těchto kódů v~roce 2013 a dokázali
nalézt klíče o velikosti přibližně $4$\;kb (!), které odpovídají $80$ bitům
bezpečnosti.


% --------------------------------------------------------------------
\subsection{CCA2-odolná konverze}\label{kap_cca2}
Jak již bylo zmíněno v kapitole~\ref{kap_slabiny}, základní varianta algoritmu
\emph{McEliece} trpí některými slabinami. Kvůli těmto slabinám by nebylo možné
algoritmů prakticky (a opakovaně) využívat. Z tohoto důvodu bylo navrženo
několik \emph{konverzí}, které jsou odolné vůči útoku s~\emph{adaptivně voleným
šifrovým textem} -- \emph{CCA2} odolné konverze.

Jsou známé \emph{obecné} konverze pro asymetrické šifry odolné vůči útoku
s~\emph{voleným šifrovým textem} (\emph{CCA1}). Například známá a  používaná
konverze \emph{OAEP} v kryptosystému \emph{RSA}. Dále to jsou např. konverze
\emph{Fujisaki-Okamoto} a \emph{Pointcheval}.

Nicméně \emph{K. Kobara} a \emph{H. Imai} v~\cite{Kobara} uvádí, že tyto
konverze nejsou \emph{CCA2}-odolné a tak stále tak umožňují např. \emph{reakční
útok} (viz kapitola~\ref{kap_slabiny}). Sami pak navrhli 3 možné
\emph{CCA2}-odolné konverze, z~nichž třetí -- označená jako \emph{Kobara-Imai
$\gamma$ konverze} -- je nejúčinější.

Tato konverze $\gamma$ je popsána algoritmem níže a ilustrována
obrázkem~\ref{obr_cca2}.

\paragraph{Značení} \hfil \\
V následujícím algoritmu bude použito toto značení:

\begin{center}
\begin{tabular}{l p{10cm}}
    $(a|b)$         &   zřetězení vektorů $a$ a $b$ \\
    $m$             &   otevřený text \\
    $const$         &   veřejně známá konstanta \\
    $r$             &   náhodné číslo (\emph{seed}) \\
    $prep(m)$       &   funkce na doplnění zprávy na požadovanou délku
                        (jednoznačný \emph{padding}) \\
    $hash(l)$       &   kryptograficky bezpečná \emph{hashovací} funkce
                        s~výstupem délky $\log_2 \binom{n}{t}$\;bitů \\
    $rand(r)$       &   kryptograficky bezpečná funkce inicializovaná
                        \emph{seedem} $r$, která vrací (pseudonáhodný) vektor
                        (\emph{CSPRNG}) \\
    $conv$          &   invertibilní konverze čísla $\leq \binom{n}{t}$ na
                        odpovídající vektor délky~$n$ a~váhy~$t$ (viz též
                        kapitola~\ref{kap_schema_pro_podpis}) \\
    $E_{\hat{G}}(m,e)$
                    &   šifrovací algoritmus \emph{McEliece} (vstupem je
                        zpráva $m$ a chybový vektor $z$) \\
    $D_G(c)$        &   dešifrovací algoritmus \emph{McEliece} \\
    $MSB_n(l)$      &   $n$ nejvíce významných (levých) bitů vektoru $l$ \\
    $LSB_n(l)$      &   $n$ nejméně významných (pravých) bitů vektoru $l$ \\
\end{tabular}
\end{center}

% todo pozice
\paragraph{Délky vektorů} \hfil \\
\begin{center}
\begin{tabular}{l l}
    Vektor      & Délka                                 \\
    \hline
    $y_1$       & $max(|rand|, n+|const|)$              \\
    $y_2$       & $max(|r|,|hash|$                      \\
    $y_3$       & $k$                                   \\
    $y_4$       & $\log_2 \binom{n}{t}$                 \\
    $y_5$       & $n + |const| + |r| - |y_4| - |y_3|$   \\
\end{tabular}
\end{center}

\begin{algoritmus}[!ht]
    \caption{Kobara-Imai konverze $\gamma$}
    \begin{algorithmic}[1]
        \Function{encrypt}{ $m$, $r$, $const$ }
        \State $\bar{m} \gets prep(m) $
        \State $ y_1 \gets rand(r) + (\bar{m}|const) $
            \Comment{1.}
        \State $ y_2 \gets r + hash(y_1) $
            \Comment{2.}
        \State $ (y_5|y_4|y_3) \gets (y_2|y_1) $

        \State $ e \gets conv(y_4) $
            \Comment{3.}
        \State $ c \gets (y_5|E_{\hat{G}}(y_3,e) $
            \Comment{4.}

        \State \Return $c$
     \EndFunction
    \end{algorithmic}

    \begin{algorithmic}[1]
        \Function{decrypt}{ $c$, $const$ }
        \State $ y_5 \gets MSB_{|c|-n} $
        \State $ (y_3,e) \gets D_G(LSB_n(c)) $
            \Comment{4.}
        \State $ y_4 \gets conv^{-1}(e) $
            \Comment{3.}
        \State $ (y_2|y_1) \gets (y_5|y_4|y_3) $

        \State $ r \gets y_2 + hash(y_1) $
            \Comment{2.}
        \State $ (\bar{m}|\bar{const}) \gets y_1 + rand(r) $
            \Comment{1.}

        \If{$\bar{const} = const$}
            \State \Return $prep^{-1}(\bar{m})$
        \Else
            \State \Return $NULL$
                \Comment{zamítni $c$}
        \EndIf
     \EndFunction
    \end{algorithmic}
\end{algoritmus}



\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{materialy/kobara-imai-cca2.png}
    \caption{Ilustrace CCA2-odolné konverze \emph{Kobara-Imai}
    $\gamma$~\cite{Repka,Kobara}}
    \label{obr_cca2}
\end{figure}

% --------------------------------------------------------------------
\subsection{Odolnost vůči kvantovým počítačům}
\cite{Post-Quantum_Cryptography}
\cite{Schanck}
% Daniel J. Bernstein,Johannes Buchmann,Erik Dahmen


% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Implementace}\label{kap_implementace}
Pro implementaci kryptosystému \emph{McEliece} v~této práci byl zvolen software
\emph{Wolfram Mathematica} \cite{Mathematica}. Tento software byl zvolen hlavně
díky pohodlnosti některých matematických výpočtů a konstrukcí a také pro
přehlednost výstupů. %TODO

Při implementaci \emph{kryptosystému} se ukázaly nedostatky softwaru
\emph{Mathematica} a bylo nutné zpracovat problematiku (rozšířených)
\emph{konečných těles} a \emph{binárních Goppa kódů}. Tyto dvě oblasti byly
implementovány přímo v~softwaru \emph{Mathematica} tak, aby bylo možné jejich
pohodlné použití i v~jiných oblastech.

Celková práce byla rozdělena do třech ucelených částí -- (binární) \emph{konečná
tělesa}, (ireducibilní) \emph{binární Goppa kódy} a \emph{kryptosystém
McEliece} --, kde každou z~nich lze využít jako \emph{balík} či \emph{knihovnu}
pro další výpočty. Následující kapitoly popisují jednotlivé části.

%\section{Wolfram Mathematica}

% ====================================================================
\section{Binární konečná tělesa}
Tato kapitola pojednává o~implementaci \emph{binárních konečných těles} včetně
jejich \emph{rozšíření}. Jsou zmíněna existující řešení v~softwaru
\emph{Mathematica}, zvolená implementace a popis implementovaných algoritmů.

\paragraph{Poznámka} \hfil \\
Ač jsou funkce implementované v~co nejobecnějším pojetí,
tak je kladen důraz na efektivnost výpočtů vzhledem k~\emph{binárním} tělesům --
tedy k~\emph{tělesům} s~charakteristikou $2$. Pro \emph{tělesa} s~jinou
charakteristikou není chování funkcí definováno.

% --------------------------------------------------------------------
\subsection{Existující řešení}
Pro operace s~\emph{konečnými tělesy} v~softwaru \emph{Mathematica} byly
prostudovány interní funkce pro operace s~polynomy a externí balík
\texttt{FiniteFields}. Vlastnosti těchto řešení jsou popsány v~následujících
kapitolách.

\subsubsection{Operace s~polynomy}
Software \emph{Mathematica} obsahuje funkce pro operace s~polynomy nad reálnými
(případně i komplexními) čísly. Většina těchto funkcí má volitelnou
\emph{možnost}\footnote{
    Anglicky se tento termín v~softwaru \emph{Mathematica}
    nazývá \emph{Option}.
} \emph{Modulus}, díky které lze zajistit, aby operace s~koeficienty byly
prováděny nad celými čísly \emph{modulo} zadané číslo $p$. Tímto způsobem je
možné implementovat operace nad tělesy $GF(p^n)$, nicméně je téměř nemožné tímto
způsobem implementovat \emph{rozšířená tělesa} -- polynomy nad polynomy.

Pro použití těchto funkcí (např. \texttt{ExtendedPolynomialGCD}, je třeba
polynomu v~úplném tvaru $\sum a_i x^i$ -- včetně $x^i$ s~tím, že $x$ musí být
nedefinovaný \emph{symbol}\footnote{
    Jinými slovy proměnná, která nemá definovanou hodnotu.
}. Tento požadavek je celkem nepraktický, protože definování této proměnné
kdekoliv v~programu by vedlo k~nemožnosti použití těchto funkcí. Navíc udržovat
si prvky ve formě např. $x^6 + x^3 + x + 1$ místo $1001011$ není pohodlné.
Další nevýhoda použití polynomů je, že software \emph{Mathematica} vypisuje
polynomy od \emph{nejnižšího} členu po \emph{nejvyšší} (např. $1+x^2+x^4+x^7$),
což je obrácený zápis, než je v~technické literatuře zvykem.

\subsubsection{Balík \texttt{FiniteFields}}
\paragraph{Balík} \emph{Balík} v~softwaru \emph{Mathematica} je soubor
obsahující rozšiřující funkce, které standardně nejsou k~dispozici. Balík je
možné načíst pomocí funkcí \texttt{Needs}, či případně \emph{Get}.

Balík \texttt{FiniteFields} obsahuje základní operace pro práci s~tělesy
$GF(p^n)$. Prvky konečných těles jsou pak určené \emph{seznamem}\footnote{
    \emph{Seznamem} se myslí struktura v~softwaru
    \emph{Mathematica} -- \emph{List}
} koeficientů a \emph{hlavičkou}, která určuje do jakého tělesa prvek patří.
Výhoda tohoto opatření je, že pro sčítání a násobení je pak možné využít
obyčejné symboly operací ($+$, $-$, $*$, $/$) a operace se automaticky provede
v~daném tělese.  Pro parametry $p$ a $n$ je určené jedno těleso $GF(p^n)$
(s~jedním konkrétním ireducibilním polynomem) a \emph{seznam} koeficientů prvku
se opět píše od nejnižšího řádu po nejvyšší (například polynom $x^3 + x + 1$
z~tělesa $GF(2^5)$ je zapsán jako $GF[2,5][\{1,1,0,1,0\}] $).

Funkce z~balíku \texttt{FiniteFields} nejsou dostatečně zdokumentovány, jak
je jinak v~softwaru \emph{Mathematica} zvykem. Nepodařilo se využít funkcí
z~tohoto balíku pro operace s~\emph{rozšířenými tělesy}.

% --------------------------------------------------------------------
\subsection{Zvolené řešení}
Existující řešení pro práci s~\emph{konečnými tělesy} se ukázala jako
nedostačující. Jejich hlavní nevýhodou je nemožnost použití při výpočtech
s~\emph{rozšířenými tělesy}. Proto bylo implementováno vlastní řešení pro práci
s~\emph{konečnými tělesy}.

Při implementaci operací nad \emph{konečnými tělesy} bylo dodržováno následující
jednotné rozhraní:

\begin{itemize}
    \item Prvky \emph{konečných těles} jsou reprezentovány \emph{seznamem}
        koeficientů od nejvyššího po nejnižší. \\ U~\emph{rozšířených těles}
        jsou koeficienty opět prvky konečných těles. \\
        Například polynom $x^3+x+1$ je reprezentován seznamem: $\{1,0,1,1\}$ \\
        a polynom $(y+1)x^2 + (y)$ je reprezentován:
        $\left\{\{1,1\},\{0,0\},\{1,0\}\right\}$

    \item Prvek (seznam koeficientů) může být libovolně dlouhý. V~případě
        potřeby se při výpočtu \emph{redukuje} (ireducibilním) polynomem nebo
        dorovná \emph{nulovými} koeficienty.

    \item Počet koeficientů vnitřních prvků (koeficientů) musí být vždy stejný. \\
        Například prvek $\{\{0,0\},\{1\},\{1,0\}\}$ není dovolený.

    \item Jednotlivým funkcím je kromě operandů předáván též i \emph{modul}
        skládající se z~odpovídajících (ireducibilních) polynomů, včetně
        charakteristiky tělesa. Tento \emph{modul} je definovaný následovně: \\
        Pro tělesa $GF(p^{n_1})$ je \emph{modul} složen z~(ireducibilního)
        polynomu $i_1$ stupně $n_1$ a dané charakteristiky $p$:
        $modul_1 = \left\{i_1,p\right\}$ \\
        Pro rozšířená tělesa se \emph{modul} skládá z~odpovídajícího
        \emph{polynomu} $i_k$ stupně $n_k$ nad tělesem
        $GF( {{p^{n_1}}^{\dots}}^{n_{k-1}} )$ a \emph{modulu vnitřního tělesa}: \\
        $modul_k = \left\{i_k,modul_{k-1}\right\}$.

    \item Všem funkcím se předávají nejdřív \emph{operandy} a poté \emph{modul}.\\
        Například pro prvky $a,b\in GF(p^{\ldots})$, $m\in\mathbb{N}$
        a odpovídající $modul$: \\
        \hspace*{0.6cm}$krat[a,b,modul]$ \\
        \hspace*{0.6cm}$inverze[a,modul]$ \\
        \hspace*{0.6cm}$mocnina[a,m,modul]$ \\
        \hspace*{0.6cm}\ldots

    \item Pro implementaci operací v~tělesech $GF(p^n)$
        jsou použité vnitřní funkce softwaru \emph{Mathematica} pro práci
        s~\emph{polynomy}. Implementované funkce pro tato tělesa tedy
        zpravidla obsahují převod ze \emph{seznamu} čísel na \emph{polynom},
        zavolání vnitřní funkce pro \emph{polynomy} a převodu zpět na
        \emph{seznam} koeficientů. Díky těmto vnitřním funkcím je docíleno
        rychlejšího výpočtu, než kdyby byla použita vlastní implementace nad
        \emph{seznamy} celých čísel.

    \item Pro implementaci operací v~\emph{rozšířených tělesech} byly
        implementovány jednotlivé algoritmy operací (popsané níže), jelikož
        nebylo možné použít pro tyto operace vnitřní funkce softwaru
        \emph{Mathematica}. Funkce nad \emph{rozšířenými tělesy} zpravidla
        volají odpovídající funkce ve vnitřních tělesech (například násobení
        jednotlivých \emph{koeficientů}).

\end{itemize}

Tato pravidla umožňují pohodlný, jednotný a \emph{rekurzivní} přístup
k~jednotlivým prvkům a voláním funkcí (druhá složka \emph{modulu} je
\emph{modul} \emph{vnitřního tělesa}, prvky \emph{polynomu} jsou opět
\emph{polynomy}, \ldots).

% --------------------------------------------------------------------
\subsection{Implementace operací}
V~následujících kapitolách je popsána implementace hlavních operací
v~\emph{konečných tělesech} a použitých algoritmů. Pro další informace je
doporučeno nahlédnout do zdrojového kódu a příkladů použití.

V~níže uvedených pseudokódech se používá některých prvků ze syntaxe softwaru
\emph{Mathematica}:

\begin{table}[!ht]
    \centering
    \begin{tabular}{l  l}
        Zápis               & Význam                                            \\
        \hline
        \texttt{foo[bar]}   & Volání funkce \emph{foo} s~argumentem \emph{bar}  \\
        \texttt{ham[[i]]}   & \emph{i}-tý prvek seznamu (pole) \emph{ham}       \\
    \end{tabular}
    \caption{Prvky syntaxe jazyka softwaru \emph{Mathematica}}
\end{table}

\subsubsection{Sčítání}
Jelikož operace sčítání se v~jakémkoliv \emph{tělese} provádí po jednotlivých
koeficientech \emph{modulo} $p$, je tato funkce jediná volána místo celkového
modulu pouze se zadanou charakteristikou $p$.

Pro \emph{rozšířená tělesa} funkce rekurzivně volá stejnou operaci sčítání na
jednotlivé koeficienty zadaných polynomů až na úroveň obyčejných jednorozměrných
seznamů. Pro sčítání těchto prvků funkce používá obyčejné sčítání dvou seznamů
modulo $p$.

\begin{algoritmus}[!ht]
    \caption{Sčítání polynomů}
    \begin{algorithmic}[1]
     \Function{plus[$a$,$b$,$p$]}{}\Comment{Pro $GF(p^n)$, $p$ je prvočíslo}
        \State \Return $Mod[a+b,p]$
     \EndFunction
    \end{algorithmic}
    \begin{algorithmic}[1]
     \Function{plus[$a$,$b$,$p$]}{}\Comment{Pro $GF(q^n)$, $q$ je $p^{\dots}$}
        \For{$ i \gets 1\dots Length[a] $}
            \State $c[[i]] \gets plus[a[[i]],b[[i]],p]$
        \EndFor
        \State \Return $c$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\paragraph{Poznámka} \hfil \\
U~dalších operací s~prvky z~tělesa $GF(p^n)$ (kde $p$ je
prvočíslo) se prvky (\emph{seznamy}) převádějí na polynomy a využívá se
implementovaných funkcí softwaru \emph{Mathematica}. Z~tohoto důvodu jsou nadále
uváděné algoritmy pouze pro \emph{rozšířená tělesa} $GF(q^n)$, kde $q$ je nějaká
mocnina prvočísla.

\subsubsection{Redukce polynomu}
Redukce polynomu (neboli \emph{modulo} polynom) se používá ve většině dalších
funkcí. Tato funkce se volá se dvěma parametry -- prvkem $a$ a polynomem
(\emph{modulem}) $m$. Funkce vrátí zbytek polynomu $a$ po dělení polynomem $m$.

Redukce polynomu pro \emph{rozšířená tělesa} je inspirovaná \emph{Comb metodou}
z~\cite{Merchan}. K~původnímu prvku $a$ se opakovaně přičítá (od
nejvyššího řádu) patřičný násobek \emph{polynomu} $m$ tak, aby se daný
koeficient $a_i$ rovnal nule (viz příklad níže).

Pro $GF(p^n)$ se používá interní funkce \texttt{PolynomialMod}

\begin{algoritmus}[!ht]
    \caption{Redukce polynomu v~tělese s~charakteristikou $2$}
    \begin{algorithmic}[1]
     \Function{redukuj[ $a$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \State $ l_a \gets stupen[a] + 1 $
            \Comment{Délka redukovaného polynomu}
        \State $ l_m \gets stupen[m]$
            \Comment{Výsledná délka redukovaného polynomu}

        // Převedení $m$ na \emph{monický} polynom
        \State $ koef \gets inverze[ m[[1]], modul_{vnitrni} ] $
            \Comment{Inverze nejvyššího koeficientu}
        \State $ m \gets krat[ koef, m, modul_{vnitrni} ] $
            \Comment{Násobení skalárem}

        \hfil
        \State $ m \gets PadRight[ m, l_a - l_m ] $
            \Comment{Natáhnutí polynomu na délku $a$}

        \For{$ i \gets 1 \ldots l_a - l_m $}
            \State $ s \gets krat[ a[[i]], m, modul_{vnitrni} ] $
                \Comment{Skalární násobek}
            \State $ a \gets plus[ a, s, 2 ] $
                \Comment{Odečtení v~binárním tělese}
            \State $ m \gets RotateRight[m] $
                \Comment{Posunutí redukovaného polynomu}
        \EndFor

        \hfil
        \State \Return $a$

     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\paragraph{Příklad} Redukce polynomu $ x^{12} + x^8 + x^7 + x^5 + x^4 + x^3 + 1 $
polynomem $ x^4 + x + 1 $ (nad tělesem $GF(2)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{align*}
& 1000110111001 \mod 10011: \\
& \arraycolsep=1pt
\begin{array}{*{13}{l}}
        1 &  0 &  0 &  0 &  1 &  1 &  0 &  1 &  1 &  1 &  0 &  0 &  1   \\
    \hline
        1 &  0 &  0 &  1 &  1 & \0 & \0 & \0 & \0 & \0 & \0 & \0 & \0   \\
       \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0 & \0 & \0 & \0   \\
       \0 & \0 & \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0 & \0   \\
       \0 & \0 & \0 & \0 & \0 & \0 &  1 &  0 &  0 &  1 &  1 & \0 & \0   \\
    \hline
          &    &    &    &    &    &    &    &    &  1 &  1 &  0 &  1   \\
\end{array}
\end{align*}

$\Rightarrow \left|1000110111001\right|_{10011} = 1101$

\subsubsection{Násobení}
Výsledkem násobení dvou polynomů $a$ a $b$ stupně $n$ a $m$ je polynom $c$
stupně $n+m$. Násobení je implementováno tak, že k~výsledku $c$ (na počátku
je to nulový polynom) se postupně přičítá skalární násobek polynomu $b$
koeficienty polynomu $a$, který je zároveň \emph{posunutý} o~patřičný počet
pozic. Využívá se zde faktu, že násobení libovolného \emph{polynomu} $A(x)$
a $x^i$ je posunutí koeficientů polynomu $A$ o~$i$ pozic doleva. Výsledný
polynom $c$ je následně \emph{redukován} zadaným modulem (viz výše).

Pro $GF(p^n)$ se používá obyčejného násobení dvou \emph{polynomů}
a následné \emph{redukce} \emph{modulem}.

\begin{algoritmus}[!ht]
    \caption{Násobení prvků}
    \begin{algorithmic}[1]
     \Function{krat[ $a$, $b$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \State $ p \gets charakteristika[ modul ] $
            \Comment{Charakteristika tělesa}

        // Natažení na výslednou délku
        \State $ b \gets PadLeft[ b, stupen[a] + stupen[b] + 1 ] $
        \State $ c \gets nulovyPolynom[\ldots ] $
            \Comment{Nulový polynom nad vnitřním tělesem}

        \hfil
        \For{$ i \gets stupen \ldots 1 $}
            \State $ s \gets krat[ a[[i]], b, modul_{vnitrni} ] $
                \Comment{Skalární násobek}
            \State $ c \gets plus[ c, s, p ] $
            \State $ b \gets RotateLeft[b] $
                \Comment{Posunutí přičítaného polynomu}
        \EndFor

        \hfil
        \State \Return $redukuj[c,modul]$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

\paragraph{Příklad} Násobení polynomu $x^3+x+1$ polynomem
$x^4+x^2+1x+1$ (nad tělesem $GF(2)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{align*}
& 1011 \cdot 10111: \\
& \arraycolsep=1pt
\begin{array}{r *{8}{l}}
        1 (x^4) &  1 &  0 &  1 &  1 & \0 & \0 & \0 & \0 \\
        0 (x^3) & \0 &  0 &  0 &  0 &  0 & \0 & \0 & \0 \\
        1 (x^2) & \0 & \0 &  1 &  0 &  1 &  1 & \0 & \0 \\
        1 (x^1) & \0 & \0 & \0 &  1 &  0 &  1 &  1 & \0 \\
        1 (x^0) & \0 & \0 & \0 & \0 &  1 &  0 &  1 &  1 \\
    \hline
                & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{array}
\end{align*}

$\Rightarrow$ Výsledek operace násobení modulo polynom $g$ se získá redukcí
polynomu $10000001$ polynomem $g$.

\subsubsection{Inverze}
Výpočet multiplikativní \emph{inverze} je implementován pomocí \emph{rozšířeného
Euklidova algoritmu}. Tento algoritmus se často vizualizuje jako výpočet tabulky
po řádkách (viz níže). Ve skutečnosti však pro výpočet dalšího řádku stačí
pracovat s~hodnotami dvou řádků předešlých. Proto si není nutné udržovat
v~paměti celou tabulku, ale stačí si udržovat hodnoty dvou řádků a po výpočtu
třetího hodnoty posunout.

Výpočet hodnot dalšího řádku tabulky probíhá následovně:
\begin{itemize}
    \item Hodnoty předchozích řádků jsou:\\
        \hspace*{0.6cm}Polynomy $p_{i-2}$ a $p_{i-1}$ (na začátku inicializovány
            na ireducibilní polynom $m$ a \emph{prvek}, ke kterému je hledaná
            inverze). \\
        \hspace*{0.6cm}Polynomy $k_{i-2}$ a $k_{i-1}$ (na začátku inicializovány
            na $0$ a $1$, respektive \emph{nulový} a \emph{jednotkový
            polynom}).

    \item Je spočítán \emph{podíl} $q$ a zbytek $p_i$ pomocí tzv. \emph{dlouhého
        dělení} polynomu $p_{i-2}$ polynomem $p_{i-1}$.

    \item Je spočítán \emph{polynom} $k_i = k_{i-2} - q \cdot k_{i-1} $

    \item Tyto kroky se opakují, dokud není získán polynom $p_i$ stupně $0$
        (jinými slovy jediný prvek vnitřního tělesa).

    \item Výsledná \emph{inverze} se získá jako skalární násobek \emph{polynomu}
        $k_i$ inverzí (posledního) \emph{koeficientu} polynomu $p_i$\footnote{
            Zde je vidět, že pro výpočet inverze v~tělese $GF(q^n)$ je třeba
            vypočítat inverzi v~tělese $GF(q)$.
        }.
\end{itemize}

Inverze v~$GF(p^n)$ je implementovaná pomocí interní funkce
\texttt{Polynomial\-ExtendedGCD}.

\begin{algoritmus}[!ht]
    \caption{Inverze prvků -- \emph{Rozšířený Euklidův algoritmus}}
    \begin{algorithmic}[1]
     \Function{inverze[ $prvek$, $modul:\left\{ m, modul_{vnitrni} \right\}$ ]}{}
        \State $ A \gets m $; $ B \gets prvek $

        // Inicializace na \emph{jednotkový} resp. \emph{nulový} polynom z~tělesa
        \State $ k_A \gets nulovyPolynom[\ldots] $;
            $ k_B \gets jednotkovyPolynom[\ldots] $
        \While{$stupen[B] \neq 0 $}

            // Výpočet $q$ a $C$ pomocí dlouhého dělení v~jednom kroku
            \State $ q   \gets A/B $; $ C   \gets A \mod B $
            \State $ k_C \gets k_A - krat[ q, k_B, modul ] $
            \State $ A \gets B$; $k_A \gets k_B$
            \State $ B \gets C$; $k_B \gets k_C$
        \EndWhile

        // Výpočet koeficientu ve vnitřním tělese
        \State $koef \gets inverze[ Last[C], modul_{vnitrni} ]$
        \State \Return $krat[ koef, k_C, modul_{vnitrni} ]$\Comment{Násobení skalárem}
     \EndFunction
    \end{algorithmic}
    \label{alg_eea}
\end{algoritmus}


\paragraph{Příklad} \emph{Rozšířený Euklidův algoritmus} pro výpočet
\emph{inverze} polynomu $x^3+x^2+1$ \emph{modulo} $x^6+x+1$ (nad tělesem
$GF(2)$):

\begin{center}
    \begin{tabular}{r|r r r}
          Podíl &    Zbytek &       Koeficienty \\
        \hline
        \hline
                & $1000011$ &       $0$ &   $1$ \\
                &    $1101$ &       $1$ &   $0$ \\
        \hline
         $1110$ &     $101$ &   $-1110$ &   $1$ \\
           $11$ &      $10$ &   $10011$ & $-11$ \\
           $10$ &       $1$ & $-101000$ & $111$
    \end{tabular}
\end{center}

$ \Rightarrow \left|1101^{-1}\right|_{1000011} = 101000 $

\paragraph{Poznámka} \hfil \\
Poslední sloupec tabulky se v~algoritmu nepočítá, je zde uveden pouze pro
úplnost.


\subsubsection{Druhá mocnina}
Pro prvky tělesa s~\emph{charakteristikou} $2$ Je výhodné implementovat funkci
\uv{na druhou} díky následujícímu tvrzení:


\begin{tvrzeni}
    Nechť $A=(a_n \dots a_2 a_1 a_0)$ je prvek tělesa
    s~\emph{charakteristikou} $2$, potom platí:
    $$ A^2 = (a_n^2 0 \dots 0 a_2^2 0 a_1^2 0 a_0^2) $$
\end{tvrzeni}

S~využitím tohoto tvrzení je realizace funkce na počítání druhé mocniny
triviální:
\begin{itemize}
    \item Provedení druhé mocniny všech koeficientů.
    \item Proložení koeficientů polynomu nulovými koeficienty.
    \item Redukování polynomem (viz výše).
\end{itemize}

\begin{algoritmus}[!ht]
    \caption{Umocňování na druhou v~tělese s~charakteristikou $2$}
    \begin{algorithmic}[1]
     \Function{naDruhou[ $a$, $\left\{m, modul_{vnitrni}\right\}$ ]}{}
        \For{$ i \gets 1 \dots Length[i]$}
            \State $ a[[i]] \gets naDruhou[ a[[i]], modul_{vnitrni} ] $
        \EndFor
        \State $ nula \gets nulovyPolynom[ \ldots ]$
            \Comment{Odpovídající nulový koeficient}
        \State $ a \gets Riffle[ a, nula ] $
            \Comment{Proloží koeficienty prvkem $nula$}
        \State \Return $ redukujPolynom[ a, modul ] $
     \EndFunction
    \end{algorithmic}
\end{algoritmus}

%TODO poradi
\paragraph{Důkaz}
\begin{align*}
    A(x)     &=  a_n x^n + \dots + a_2 x^2 + a_1 x + a_0 \\
    {A(x)}^2 &=  (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0)\cdot(a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) =  \\
             &= a_n x^n   \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {}                              \\
             & \qquad \vdots                                                                                \\
             &  {} + a_2 x^2   \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {}                         \\
             &  {} + a_1 x \, \:  \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) + {}                      \\
             &  {} + a_0 \quad \cdot (a_n x^n + \dots + a_2 x^2 + a_1 x + a_0) =                            \\
             &= a_n^2 x^{2n}    + \dots + a_n a_2 x^{n+2} + a_n a_1 x^{n+1} + a_n a_0 x^n + {}              \\
             & \qquad \vdots                                                                                \\
             &  {} + a_n a_2 x^{n+2} + \dots + a_2^2 x^4       + a_2 a_1 x^3     + a_2 a_0 x^2 + {}         \\
             &  {} + a_n a_1 x^{n+1} + \dots + a_2 a_1 x^3     + a_1^2 x^2       + a_1 a_0 x   + {}         \\
             &  {} + a_n a_0 x^n     + \dots + a_2 a_0 x^2     + a_1 a_0 x       + a_0^2       =            \\
             &= a_n^2 x^{2n} + \dots  + 2 ( a_3 a_0 + a_2 a_1 ) x^3  + 2 ( a_2 a_0 ) x^2 + a_1^2 x^2 + 2 ( a_1 a_0 ) x + a_0^2 = \\
             &= \sum_{i=0}^{n} a_i^2 x^{2i} + 2 \sum_{i=1}^{n+1}\sum_{\substack{j<k \\ j+k = i}} a_j a_k =  \\
             &= \sum_{i=0}^{n} a_i^2 x^{2i}
    \hspace{2.5cm} \cong (a_n^2 0 \dots 0 a_2^2 0 a_1^2 0 a_0^2)
%             &= a_n^2 x^{2n} + \dots + a_2 x^4 + a_1^2 x^2 + a_0^2  \\
\end{align*}

\subsubsection{Mocnění}
Mocnění \emph{polynomů} je implementováno pomocí algoritmu
\emph{Square-and-Multiply} (\emph{SM}). Algoritmus využívá faktu, že libovolnou
mocninu lze rozložit na součin mocnin čtverců ($^2$,$^4$,$^8$,\dots). Konkrétně
byla implementována varianta provádějící výpočet od nejvíce významného bitu
exponentu\footnote{
    Uváděna jako \emph{MSB} -- z~anglického \emph{most significant bit}
}. Algoritmus má vstupy polynom $a$ a exponent $e$. Exponent se vyjádří jako
číslo v~\emph{binární} soustavě a poté algoritmus provádí cyklus přes bity
tohoto rozvoje. V~každém kroku se mezivýsledek umocní na druhou a v~případě, že
je odpovídající bit exponentu $1$, přinásobí se původní číslo $a$.


\begin{algoritmus}[!ht]
    \caption{Umocňování prvku $a^e \mod modul$ -- \emph{Square-and-Multiply}}
    \begin{algorithmic}[1]
     \Function{umocni[ $a$, $e$, $modul$ ]}{}
        \If{$ e = 0 $}
            \State \Return $nulovyPolynom[\ldots]$
                \Comment{Nulový prvek tělesa}
        \EndIf
        \State $ rozvoj \gets IntegerDigits[ e, 2 ] $
            \Comment{Binární rozvoj exponentu}
        \State $ c \gets a $
            \Comment{$rozvoj[[1]]$ je vždy $1$}
        \For{$ i \gets 2 \ldots Length[rozvoj] $}
            \State $ s \gets naDruhou[ c, modul ] $
            \State $ m \gets krat[ s, a, modul ] $
            \If{$ rozvoj[[i]] = 0 $}
                \State $ c \gets s $
            \Else
                \State $ c \gets m $
            \EndIf
        \EndFor
        \State \Return $c$
     \EndFunction
    \end{algorithmic}
\end{algoritmus}


\paragraph{Poznámka} \hfil \\
Takto implementovaný algoritmus je zranitelný vůči odběrové a~časové analýze.
Pro odolnou implementaci je nutné počítat násobek \emph{vždy} a~pokud je daný
bit exponentu $1$, přiřadit násobek do mezi výpočtu. Pseudokód i~reálná
implementace je prováděna tímto (bezpečným) způsobem.

\paragraph{Příklad} \emph{Square-and-Multiply} pro výpočet
$\left(x^3+1\right)^{26}$ \emph{modulo} $x^6+x+1$ (nad tělesem $GF(2)$):

%\renewcommand{\0}{{\scriptscriptstyle 0}}
\begin{center}
    \begin{tabular}{c|r|l|r|r}
        \multirow{2}{*}{Op.} & \multicolumn{2}{c}{Mocnina} & \multicolumn{1}{c}{\multirow{2}{*}{Výpočet}} & \multirow{2}{*}{Výsledek} \\
                &  dek. & bin.    &                   &              \\
        \hline
        \hline
                & $  1$ & $1    $ &                   & $ 1001$      \\
        \hline
    \textbf{S}  & $  2$ & $1    $ & $    1\00\00\01 $ & $   10$      \\
    \textbf{M}  & $  3$ & $11   $ & $ 10 \cdot 1001 $ & $10010$      \\
        \hline
    \textbf{S}  & $  6$ & $110  $ & $ 1\00\00\01\00 $ & $ 1000$      \\
        \hline
    \textbf{S}  & $ 12$ & $1100 $ & $    1\00\00\00 $ & $   11$      \\
    \textbf{M}  & $ 13$ & $1101 $ & $ 11 \cdot 1001 $ & $11011$      \\
        \hline
    \textbf{S}  & $ 26$ & $11010$ & $     1\01\00\01\01 $ & $ 1010$      \\
    \end{tabular}
\end{center}

$ \Rightarrow \left|1001^{26}\right|_{1000011} = 1010 $

% --------------------------------------------------------------------
\subsection{Možná zlepšení}
V~této kapitole jsou nastíněny možná zlepšení implementace, která
zrychlují výpočet některých operací.

\subsubsection{Logaritmické tabulky}
Pro zrychlení výpočtu násobení a mocnin prvku lze v~\emph{konečném tělese}
využít faktu, že vždy existuje \emph{primitivní prvek} a převádět tak operace
v~tělese na operace s~celými čísly.

\begin{definice}
    Nechť $\alpha$ je \emph{generátor} \emph{multiplikativní grupy} tělesa $F$.
    Potom říkáme, že $\alpha$ je \emph{primitivní prvek} tělesa $F$.
\end{definice}

\paragraph{Důsledek} Každý prvek tělesa $F$ -- kromě \emph{nulového} prvku
\emph{aditivní grupy} -- lze vyjádřit jako $\alpha^i$ pro nějaké $i$.

Důkaz plyne přímo z~definice.

Násobení dvou prvků $a = \alpha^{i_a}$ a $b = \alpha^{i_b}$ tak lze převést na
součet mocnin \emph{primitivního prvku}:
$$ a \cdot b = \alpha^{i_a} \cdot \alpha^{i_b} = \alpha^{i_a + i_b} $$

Podobným způsobem je možné zjednodušit umocňování prvku:
$$ a^e = \left(\alpha^i\right)^e = \alpha^{i e} $$

V~obou případech je samozřejmě možné použít \emph{Eulerovu větu} a mocniny
redukovat \emph{modulo} $N$, kde $N$ je počet prvků \emph{multiplikativní grupy
tělesa} ($N=p^n-1$ pro těleso $GF(p^n)$). Jakoukoliv operací násobení a mocnění
se získá prvek $\alpha^{n_c}$, kde $n_c$ je celé číslo v~rozsahu od $0$ do
$N-1$.

Reprezentací prvků pomocí odpovídajících mocnin \emph{primitivního prvku} je tak
možné vyhnout se násobení a umocňování prvků v~tělese a nahradit ho sčítáním a
násobením celých čísel, což je řádově jednodušší. V~případě sčítání prvků
v~tělese je však nutné mít jejich standardní reprezentaci (seznam koeficientů),
jelikož se sčítání provádí po jednotlivých koeficientech, respektive bitech.
Není možné nahradit sčítání dvou prvků jiné operaci s~mocninami
\emph{primitivního prvku}.

Pro použití tohoto zrychlení výpočtů je tak nutné připravit v~paměti programu
překladové \emph{log}- a \emph{antilogaritmické} tabulky pro překlad prvků
z~jedné reprezentace na druhou.

Ač se tak získá podstatné zrychlení výpočtů v~tělese, existuje několik nevýhod
tohoto přístupu:

\begin{itemize}
    \item Je nutné nalézt \emph{primitivní prvek tělesa}.

    \item Je nutné vygenerovat a uchovat v~paměti počítače obě tabulky pro
        překlad.
        \begin{itemize}
            \item Tato tabulka lze implementovat pomocí obyčejného pole či
                %todo
                % seznamu, kde se k~danému indexu v~seznamu vyskytuje
                sezna\-mu, kde se k~danému indexu v~seznamu vyskytuje
                odpovídající hodnota.
            \item Pro binární  tělesa $GF(2^m)$ je velikost jedné tabulky
                $O(m 2^m)$ (konkrétně $2^m - 1$ hodnot, kde každá je
                reprezentována $m$ bity).
            \item Jelikož je paměťová náročnost \emph{exponenciální}, je
                možné tyto tabulky uchovávat pouze pro \emph{malá} $m$ (např.
                $8$ či $16$, nikoliv však $1024$).
        \end{itemize}

    \item \emph{Nulový prvek} tělesa není možné žádným způsobem zobrazit jako
        mocninu. Při každé operaci je potřeba s~touto skutečností počítat
        a hlídat jako výjimku.

\end{itemize}


Tohoto vylepšení se dá využít pro operace ve \emph{vnitřním tělese}
$GF(2^m)$, nad kterým jsou postavené polynomy v~\emph{binárních Goppa kódech}.


\subsubsection{Implementace dělení}
Dělení prvkem $b$ v~\emph{konečném tělese} se převádí na násobení $b^{-1}$. Pro
výpočet \emph{podílu} se tak počítá inverze a následně násobek. Je ale možné
implementovat rovnou algoritmus pro dělení.

Algoritmus pro dělení prvku $a$ prvkem $b$ je totožný s~algoritmem pro výpočet
\emph{inverze} prvku $b$ s~tím rozdílem, že je počáteční hodnota koeficientu
$k_b$ (viz \emph{EEA} -- alg. \ref{alg_eea}) nastavena na hodnotu $a$.
%Jelikož průběh algoritmu odpovídá ekvivalentním úpravám rovnic,
%algoritmus skončí s rovnicí:
%
%$$ 1 = (l \cdot a ) \cdot b  + k \cdot m $$
Výsledkem algoritmu pak bude inverze prvku $b$ vynásobená $a$, což přesně
odpovídá výrazu $a/b$.


% ====================================================================
\section{Ireducibilní binární Goppa kódy}

% ====================================================================
\section{McEliece}

% ====================================================================
\section{Měření}




% ====================================================================
% ====================================================================
% ====================================================================
\begin{conclusion}
        %sem napište závěr Vaší práce
    draft \cite{Schanck}
\end{conclusion}




% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Prilohy
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

%\bibliographystyle{csn690}
%\bibliography{mybibliographyfile}
\begin{thebibliography}{99}

% články, knihy
    \bibitem{McEliece}
        Robert J. \textsc{McEliece}, A~Public-Key Cryptosystem Based on
        Algebraic Coding Theory v~\emph{JPL Deep Space Network Progress Report
        42-44} Jenuary and February 1978, strany 114–116. Dostupné online
        \url{http://ipnpr.jpl.nasa.gov/progress_report2/42-44/44N.PDF}

    \bibitem{Berlekamp}
        Elwyn R. \textsc{Berlekamp}, Robert J. \textsc{McEliece}, Henk C. A. van
        \textsc{Tilborg}.  On the Inherent Intractibility v~\emph{IEEE
        Transactions of Information Theory}, vol. IT-24, No. 3, strany 384-386.
        IEEE, květen 1978.

    \bibitem{Bernstein}
        Daniel J. \textsc{Bernstein}, Tanja \textsc{Lange}, Christiane
        \textsc{Peters}. Attacking and Defending the McEliece Cryptosystem
        v~\emph{Post-Quantum Cryptography}, strany 31-46. Springer Berlin
        Heidelberg 2008. Dostupné online
        \url{http://link.springer.com/chapter/10.1007/978-3-540-88403-3\_3}

    \bibitem{Berson}
        T. A. \textsc{Berson}. Failure of the McEliece public-key cryptosystem under
        message-resend and related-message attack v~\emph{Advances in
        Cryptology–CRYPTO ’97}, vol. 1294, strany 213-200, Springer Berlin, 1997.

    \bibitem{Brickell}
        E. F. \textsc{Brickell}, A. M. \textsc{Odlyzko}. Cryptanalysis: a survey
        of recent results v~\emph{Proceedings of the IEEE}, vol. 76, strany
        578-593. IEEE, 1988. Dostupné online
        \url{http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=4443}

    \bibitem{Canteaut}
        Anne \textsc{Canteaut}, Florent \textsc{Chabaud}. Improvements of
        the Attacks on Cryptosystems Based on Error-Correcting Codes,
        v~\emph{Research Report LIENS-95-21}. École Normale Supérieure, 1995
        Dostupné online
        \url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.32.1645}

    \bibitem{Courtois}
        Nicolas T. \textsc{Courtois}, Matthieu \textsc{Finiasz}, Nicolas
        \textsc{Sendrier}. How to Achieve a McEliece-Based Digital Signature
        Scheme v~\emph{Advances in Cryptology -- ASIACRYPT 2001}, strany
        157-174. Springer Berlin Heidelberg, 2001. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F3-540-45682-1\_10}

    \bibitem{Engelbert}
        Daniela \textsc{Engelbert}, Raphael \textsc{Overbeck}, Arthur
        \textsc{Schmidt}. A~Summary of McEliece-Type Cryptosystems and their
        Security v~\emph{Journal of Mathematical Cryptology}. IACR 2006.
        Dostupné online \url{http://eprint.iacr.org/2006/162}

    \bibitem{Faugere1}
        Jean-Charles \textsc{Faugère}, Ayoub \textsc{Otmani}, Ludovic
        \textsc{Perret}, Jean-Pierre \textsc{Tillich}. Algebraic Cryptanalysis
        of McEliece Variants with Compact Keys v~\emph{Advances in Cryptology}
        -- EUROCRYPT 2010. Springer Berlin Heidelberg, 2010. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F978-3-642-13190-5\_14}

    \bibitem{Faugere2}
        Jean-Charles \textsc{Faugre}, Ayoub \textsc{Otmani} , Ludovic
        \textsc{Perret}, Frederic de \textsc{Portzamparc}, Jean-Pierre
        \textsc{Tillich}. \emph{Structural Cryptanalysis of McEliece Schemes
        with Compact Keys}. IACR Cryptology ePrint Archive, 2014. Dostupné
        online \url{https://eprint.iacr.org/2014/210.pdf}

%    \bibitem{Fujisaki1}
%        Eiichiro \textsc{Fujisaki}, Tatsuaki \textsc{Okamoto}. How to Enhance the Security
%        of Public-Key Encryption at Minimum Cost v \emph{Public Key
%        Cryptography}, vol. 1560, strany 53-68. Springer Berlin Heidelberg, 1999.
%
%    \bibitem{Fujisaki2}
%        Eiichiro \textsc{Fujisaki}, Tatsuaki \textsc{Okamoto}. Secure
%        Integration of Asymmetric and Symmetric Encryption Schemes
%        v~\emph{CRYPTO}, vol. 1666, strany 535-554. 1999.

    \bibitem{Heyse}
        Stefan \textsc{Heyse}. \emph{Code-based Cryptography}: Implementing the
        McEliece Scheme on Reconfigurable Hardware. Ruhr-University Bochum,
        2009.

    \bibitem{Jabri}
        A. Al \textsc{Jabri}. A Statistical Decoding Algorithm for General
        Linear Block Codes v \emph{Cryptography and Coding}, vol. 2260, strany
        1-8. Springer Berlin Heidelberg, 2001. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F3-540-45325-3\_1}

    \bibitem{Kobara}
        Kazukuni \textsc{Kobara}, Hideki \textsc{Imai}. Semantically Secure
        McEliece Public-Key Cryptosystems -- Conversions for McEliece PKC v
        \emph{Public Key Cryptography}, vol. 1992, strany 19-35. Springer Berlin
        Heidelberg, 2001. Dostupné online
        \url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.9666}

    \bibitem{Kratochvil}
        Miroslav \textsc{Kratochvíl}. \emph{Implementation of cryptosystem
        based on error-correcting codes}. Matematicko-fyzikální fakulta
        Univerzity Karlovy, Praha, 2013.

    \bibitem{Lee}
        P. J. \textsc{Lee}, E. F. \textsc{Brickell}. An Observation on the
        Security of McEliece's Public-Key Cryptosystem v~\emph{Advances in
        Cryptology} -- EUROCRYPT '88, strany 275-280. Springer Berlin
        Heidelberg, 1988. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F3-540-45961-8\_25}

    \bibitem{Leon}
        J. S. \textsc{Leon}. A~probabilistic algorithm for computing minimum
        weights of large error-correcting codes v~\emph{IEEE Transactions on
        Information Theory}, vol. 34, strany 1354-1359. IEEE, 1988. Dostupné
        online
        \url{http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=21270}

        %todo
        \vfil
    \bibitem{Merchan}
        J. G. \textsc{Merchan}, S. \textsc{Kumar}, C. \textsc{Paar},
        J. \textsc{Pelzl}. Efficient Software Implementation of Finite
        Fields with Applications to Cryptography v~\emph{Acta Applicandae
        Mathematicae: An International Survey Journal on Applying Mathematics
        and Mathematical Applications}, Volume 93, Numbers 1-3, strany  3-32.
        Ruhr-Universitat Bochum, 2006. Dostupné online:
        \url{http://www.emsec.rub.de/research/publications/efficient-software-implementation-finite-fields-ap/}

    \bibitem{Misoczki1}
        Rafael \textsc{Misoczki}, Paulo S. L. M. \textsc{Barreto}. Compact
        McEliece Keys from Goppa Codes v~\emph{Selected Areas in Cryptography}:
        16th Annual International Workshop, strany 376-392. Springer Berlin
        Heidelberg, 2009. Dostupné online
        \url{http://link.springer.com/chapter/10.1007\%2F978-3-642-05445-7\_24}

    \bibitem{Misoczki2}
        Rafael \textsc{Misoczki}, Jean-Pierre \textsc{Tillich}, Nicolas
        \textsc{Sendrier}, Paulo S. L. M. \textsc{Barreto}. MDPC-McEliece: New
        McEliece variants from Moderate Density Parity-Check codes
        v~\emph{Information Theory Proceedings}, strany 2069-2073. IEEE, 2013
        Dostupné online
        \url{http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6620590}

    \bibitem{Niederreiter}
        Harald \textsc{Niederreiter}. Knapsack-type cryptosystems and
        algebraic coding theory v~\emph{Problems of Control and Information
        Theory 15}, strany 19-34. 1986

    \bibitem{Paar}
        Christof \textsc{Paar}, Jan \textsc{Pelzl}. \emph{Understanding
        Cryptography}: A~Textbook for Students and Practitioners.
        Springer-Verlag Berlin Heidelberg, 2010. Dostupné
        online: \url{https://www.springer.com/us/book/9783642041006}

    \bibitem{Paustjan}
        Olga \textsc{Paustjan}. \emph{Post Quantum Cryptography on Embedded
        Devices}: An Ecient Implementation of the McEliece Public Key Scheme
        based on Quasi-Dyadic Goppa Codes. Ruhr-University Bochum, 2010.

%    \bibitem{Pointcheval}

    \bibitem{Randall}
        Dana \textsc{Randall}. \emph{Efficient Generation of Random Nonsingular
        Matrices}. EECS Department, University of California, 1991. Dostupné
        online
        \url{http://www.eecs.berkeley.edu/Pubs/TechRpts/1991/CSD-91-658.pdf}

    \bibitem{Repka}
        Marek \textsc{Repka}, Pavol \textsc{Zajac}. Overview of the McEliece
        Cryptosystem and its Security v~\emph{Tatra Mountains Mathematical
        Publications}, vol. 60, strany 57-83. Slovak Academy of Sciences, 2014.
        Dostupné online
        \url{http://www.degruyter.com/view/j/tmmp.2014.60.issue-1/tmmp-2014-0025/tmmp-2014-0025.xml}

    \bibitem{Sendrier}
        Nicolas \textsc{Sendrier}. Finding the Permutation Between Equivalent
        Linear Codes: The Support Splitting Algorithm v~\emph{Transactions on
        Information Theory}, vol. 46. IEEE 2000. Dostupné online
        \url{http://ieeexplore.ieee.org/xpl/abstractAuthors.jsp?arnumber=850662}

    \bibitem{Schanck}
        J. M. Schanck, W. Whyte, Z. Zhang. Criteria for selection of public-key
        cryptographic algorithms for quantum-safe hybrid cryptography
        (Internet-draft). IETF, 2016. Dostupné online
        \url{https://datatracker.ietf.org/doc/draft-whyte-select-pkc-qsh/}

    \bibitem{Sidelnikov}
        V. M. \textsc{Sidelnikov}, S. O. \textsc{Shestakov}. On insecurity of
        cryptosystems based on generalized Reed-Solomon codes v~\emph{Discrete
        Mathematics and Applications} vol. 2, strany 439-444. Walter de Gruyter
        1992. Dostupné online
        \url{https://www.researchgate.net/publication/250969195\_On\_insecurity\_of\_cryptosystems\_based\_on\_generalized\_Reed-Solomon\_codes}

    \bibitem{Stern}
        Jacques \textsc{Stern}. A~method for finding code words of small weight,
        v~\emph{Coding Theory and Applications}, 3rd International Colloquium,
        strany 106-113. Springer Berlin Heidelberg, 1988. Dostupné online
        \url{http://link.springer.com/chapter/10.1007/BFb0019850}

    \bibitem{ITT}
        Toshiya \textsc{Itoh}, Shigeo \textsc{Tsujii}. A~fast algorithm for
        computing multiplicative inverses in $GF(2^m)$ using normal bases
        v~\emph{Information and Computation}, vol. 78, strany 171-177. Academic
        Press, 1988.  Dostupné online
        \url{http://www.sciencedirect.com/science/article/pii/0890540188900247}

    \bibitem{Umana}
        Valérie Gauthier \textsc{Umaña}, Gregor \textsc{Leander}.
        \emph{Practical Key Recovery Attacks on two McEliece Variants}.
        IACR Cryptology ePrint Archive, 2009.  Dostupné online
        \url{https://eprint.iacr.org/2009/509.pdf}

    \bibitem{XingLi}
        Yuan \textsc{Xing Li}, Robert H. \textsc{Deng}, Xin \textsc{Mei Wang}.
        On the equivalence of McEliece's and Niederreiter's public-key
        cryptosystems v~\emph{IEEE Transactions on Information Theory}, vol. 40,
        strany 271-273. IEEE, leden 1994. Dostupné online
        \url{http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=272496}

    \bibitem{Post-Quantum_Cryptography}
        Post-Quantum Cryptography
% přednášky
    \bibitem{FIT_BHW} Přednášky MI-BHW
    \bibitem{FIT_KRY} Přednášky MI-KRY
    \bibitem{FIT_LIN} Přednášky BI-LIN
    \bibitem{FIT_MKY} Přednášky MI-MKY
    \bibitem{FIT_MPI} Přednášky MI-MPI

% software
    \bibitem{Mathematica} Wolfram Mathematica
\end{thebibliography}

\appendix

% ====================================================================
% ====================================================================
\chapter{Seznam použitých zkratek}
% \printglossaries
\begin{description}
        \item[CCA2] \emph{Adaptive Chosen Ciphertext Attack} -- útok s~adaptivní volbou šifrového textu
        \item[DH]   Algoritmus \emph{Diffie-Hellman}
        \item[DSA]  \emph{Digital Signature Algorithm}
        \item[ECC]  \emph{Elliptic Curve Cryptography}
        \item[EEA]  \emph{Extended Euclidean Algorithm} -- rozšířený Euklidův algoritmus
        \item[GCD]  \emph{Greatest Common Divisor} -- největší společný dělitel
        \item[GRS]  \emph{Generalised Reed-Solomon code} -- zobecněný Reed-Solomon kód
        \item[GF]   \emph{Gallois field} -- konečné těleso
        \item[LSB]  \emph{Least Significant Bit}/\emph{Byte} -- nejméně významný bit/bajt
        \item[MDCP] \emph{Moderate Density Parity-Check} kódy
        \item[MSB]  \emph{Most Significant Bit}/\emph{Byte} -- nejvíce významný bit/bajt
        \item[OAEP] \emph{Optimal asymmetric encryption padding} -- schéma pro asymetrické šifrování
        \item[RSA]  Algoritmus \emph{RSA} -- \emph{Rivest}, \emph{Shamir}, \emph{Adleman}
        \item[S\&M] Algoritmus \emph{Square-and-Multiply}
        %\item[TLS] Three Letter Shortcut
\end{description}

% TODO
%\chapter{Algoritmy}
%\section{ITT}
%TBA

% ====================================================================
% ====================================================================
% ====================================================================
\chapter{Obsah přiloženého CD}

%upravte podle skutecnosti

%TODO
\begin{figure}
        \dirtree{%
                .1 readme.txt\DTcomment{stručný popis obsahu CD}.
                .1 exe\DTcomment{adresář se spustitelnou formou implementace}.
                .1 src.
                .2 impl\DTcomment{zdrojové kódy implementace}.
                .2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
                .1 text\DTcomment{text práce}.
                .2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
                .2 thesis.ps\DTcomment{text práce ve formátu PS}.
        }
\end{figure}

\end{document}

